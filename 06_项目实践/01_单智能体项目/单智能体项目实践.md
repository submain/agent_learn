# 单智能体项目实践

## 项目概述

本阶段通过三个完整的单智能体项目，将前面学习的理论知识转化为实际开发能力。每个项目都基于LangChain 1.0框架，涵盖不同应用场景和复杂度。

## 项目一：智能客服助手

### 项目背景
构建一个能够处理用户咨询、提供产品信息、处理售后问题的智能客服助手。

### 技术栈
- LangChain 1.0 (langchain-core, langchain-openai)
- DeepSeek API
- 向量数据库（FAISS）
- 工具调用（搜索、查询数据库）

### 项目结构

```
customer_service_agent/
├── config.py           # 配置文件
├── tools/              # 工具定义
│   ├── __init__.py
│   ├── search_tool.py
│   ├── database_tool.py
│   └── order_tool.py
├── memory/             # 记忆管理
│   ├── __init__.py
│   └── conversation_memory.py
├── agent.py            # 智能体核心
├── prompts.py          # 提示词模板
└── main.py             # 主程序入口
```

### 核心代码实现

#### 1. 配置文件 (config.py)

```python
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    DEEPSEEK_API_KEY = os.getenv("DEEPSEEK_API_KEY")
    DEEPSEEK_MODEL = "deepseek-chat"
    TEMPERATURE = 0.7
    MAX_TOKENS = 2000
    
    # 向量数据库配置
    VECTOR_DB_PATH = "./data/vector_db"
    
    # 工具配置
    SEARCH_API_KEY = os.getenv("SEARCH_API_KEY")
    DATABASE_URL = os.getenv("DATABASE_URL")
```

#### 2. 工具定义 (tools/search_tool.py)

```python
from langchain_core.tools import tool
from typing import Optional
import requests

@tool
def search_product_info(query: str) -> str:
    """搜索产品信息
    
    Args:
        query: 搜索查询字符串
    
    Returns:
        产品信息的文本描述
    """
    product_db = {
        "手机": {
            "价格": "2999元",
            "库存": "充足",
            "描述": "高性能智能手机，搭载最新处理器"
        },
        "电脑": {
            "价格": "5999元",
            "库存": "少量",
            "描述": "轻薄便携，适合办公和学习"
        },
        "耳机": {
            "价格": "299元",
            "库存": "充足",
            "描述": "无线蓝牙耳机，降噪功能强大"
        }
    }
    
    for product, info in product_db.items():
        if product in query:
            return f"{product}：{info['描述']}，价格：{info['价格']}，库存：{info['库存']}"
    
    return f"未找到关于'{query}'的产品信息"
```

#### 3. 工具定义 (tools/order_tool.py)

```python
from langchain_core.tools import tool
from typing import Dict, List
import json

@tool
def create_order(product_name: str, quantity: int = 1) -> str:
    """创建订单
    
    Args:
        product_name: 产品名称
        quantity: 购买数量
    
    Returns:
        订单创建结果
    """
    order_id = f"ORD{hash(product_name + str(quantity)) % 100000:05d}"
    
    order_info = {
        "order_id": order_id,
        "product": product_name,
        "quantity": quantity,
        "status": "已创建",
        "message": f"订单创建成功！订单号：{order_id}"
    }
    
    return json.dumps(order_info, ensure_ascii=False)

@tool
def query_order_status(order_id: str) -> str:
    """查询订单状态
    
    Args:
        order_id: 订单号
    
    Returns:
        订单状态信息
    """
    orders = {
        "ORD12345": {"status": "已发货", "tracking": "SF1234567890"},
        "ORD23456": {"status": "待发货", "tracking": None},
        "ORD34567": {"status": "已完成", "tracking": "SF0987654321"}
    }
    
    if order_id in orders:
        order = orders[order_id]
        return f"订单{order_id}状态：{order['status']}"
    else:
        return f"未找到订单{order_id}"
```

#### 4. 记忆管理 (memory/conversation_memory.py)

```python
from langchain_core.messages import BaseMessage
from langchain_core.chat_history import BaseChatMessageHistory
from typing import List, Dict
import json
from datetime import datetime

class FileChatMessageHistory(BaseChatMessageHistory):
    """基于文件的对话历史记录"""
    
    def __init__(self, session_id: str, file_path: str = "./data/chat_history"):
        self.session_id = session_id
        self.file_path = f"{file_path}/{session_id}.json"
        self.messages: List[BaseMessage] = []
        self._load_history()
    
    def _load_history(self):
        """加载历史记录"""
        try:
            with open(self.file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.messages = [self._message_from_dict(msg) for msg in data]
        except FileNotFoundError:
            self.messages = []
    
    def _message_from_dict(self, msg_dict: Dict) -> BaseMessage:
        """从字典创建消息对象"""
        from langchain_core.messages import HumanMessage, AIMessage
        
        if msg_dict["type"] == "human":
            return HumanMessage(content=msg_dict["content"])
        elif msg_dict["type"] == "ai":
            return AIMessage(content=msg_dict["content"])
        else:
            raise ValueError(f"Unknown message type: {msg_dict['type']}")
    
    def add_message(self, message: BaseMessage) -> None:
        """添加消息"""
        self.messages.append(message)
        self._save_history()
    
    def _save_history(self):
        """保存历史记录"""
        import os
        os.makedirs(os.path.dirname(self.file_path), exist_ok=True)
        
        data = []
        for msg in self.messages:
            msg_dict = {
                "type": "human" if isinstance(msg, HumanMessage) else "ai",
                "content": msg.content
            }
            data.append(msg_dict)
        
        with open(self.file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    
    def clear(self) -> None:
        """清空历史记录"""
        self.messages = []
        self._save_history()

def get_session_history(session_id: str) -> BaseChatMessageHistory:
    """获取会话历史"""
    return FileChatMessageHistory(session_id)
```

#### 5. 提示词模板 (prompts.py)

```python
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder

SYSTEM_PROMPT = """你是一个专业的智能客服助手，负责回答用户的咨询、提供产品信息、处理售后问题。

你的职责包括：
1. 回答产品相关问题（价格、规格、库存等）
2. 帮助用户创建订单
3. 查询订单状态
4. 处理售后问题
5. 提供购物建议

注意事项：
- 使用友好、专业的语气
- 如果不确定答案，诚实地告诉用户
- 尽量使用工具获取准确信息
- 保持对话的连贯性
"""

CUSTOMER_SERVICE_PROMPT = ChatPromptTemplate.from_messages([
    ("system", SYSTEM_PROMPT),
    MessagesPlaceholder(variable_name="chat_history"),
    ("human", "{input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad")
])
```

#### 6. 智能体核心 (agent.py)

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_core.runnables.history import RunnableWithMessageHistory
from langchain_core.messages import HumanMessage, AIMessage
from typing import List
from config import Config
from prompts import CUSTOMER_SERVICE_PROMPT
from tools.search_tool import search_product_info
from tools.order_tool import create_order, query_order_status
from memory.conversation_memory import get_session_history

class CustomerServiceAgent:
    """智能客服智能体"""
    
    def __init__(self):
        self.llm = ChatOpenAI(
            model=Config.DEEPSEEK_MODEL,
            api_key=Config.DEEPSEEK_API_KEY,
            temperature=Config.TEMPERATURE,
            max_tokens=Config.MAX_TOKENS,
            base_url="https://api.deepseek.com"
        )
        
        self.tools = [search_product_info, create_order, query_order_status]
        
        self.agent = create_tool_calling_agent(
            self.llm,
            self.tools,
            CUSTOMER_SERVICE_PROMPT
        )
        
        self.agent_executor = AgentExecutor(
            agent=self.agent,
            tools=self.tools,
            verbose=True,
            handle_parsing_errors=True,
            max_iterations=5
        )
        
        self.chain_with_history = RunnableWithMessageHistory(
            self.agent_executor,
            get_session_history,
            input_messages_key="input",
            history_messages_key="chat_history"
        )
    
    def chat(self, user_input: str, session_id: str = "default") -> str:
        """与用户对话"""
        try:
            response = self.chain_with_history.invoke(
                {"input": user_input},
                config={"configurable": {"session_id": session_id}}
            )
            return response["output"]
        except Exception as e:
            return f"抱歉，处理您的请求时出现错误：{str(e)}"
    
    def clear_history(self, session_id: str = "default"):
        """清空对话历史"""
        history = get_session_history(session_id)
        history.clear()
```

#### 7. 主程序 (main.py)

```python
from agent import CustomerServiceAgent
import sys

def main():
    print("=" * 60)
    print("智能客服助手")
    print("=" * 60)
    print("输入 'quit' 或 'exit' 退出程序")
    print("=" * 60)
    
    agent = CustomerServiceAgent()
    session_id = "customer_session_001"
    
    while True:
        user_input = input("\n用户: ").strip()
        
        if user_input.lower() in ['quit', 'exit']:
            print("感谢使用，再见！")
            break
        
        if not user_input:
            continue
        
        print("\n助手: ", end="", flush=True)
        response = agent.chat(user_input, session_id)
        print(response)

if __name__ == "__main__":
    main()
```

### 项目特点

1. **工具集成**：集成多个工具（搜索、订单创建、订单查询）
2. **记忆管理**：持久化存储对话历史，支持上下文理解
3. **错误处理**：完善的异常处理机制
4. **可扩展性**：模块化设计，易于添加新功能

### 运行说明

1. 安装依赖：
```bash
pip install langchain langchain-core langchain-openai python-dotenv
```

2. 配置环境变量：
```bash
DEEPSEEK_API_KEY=your_api_key
```

3. 运行程序：
```bash
python main.py
```

## 项目二：个人知识管理助手

### 项目背景
构建一个能够帮助用户管理个人知识、整理笔记、回答问题的知识管理助手。

### 技术栈
- LangChain 1.0
- DeepSeek API
- FAISS向量数据库
- 文档加载器

### 核心功能

1. **知识库管理**：上传、删除、搜索文档
2. **智能问答**：基于知识库回答问题
3. **笔记整理**：自动整理和分类笔记
4. **知识关联**：发现知识点之间的关联

### 关键代码片段

#### 知识库管理

```python
from langchain_community.vectorstores import FAISS
from langchain_openai import OpenAIEmbeddings
from langchain_community.document_loaders import TextLoader, PyPDFLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter

class KnowledgeBase:
    """知识库管理"""
    
    def __init__(self, persist_directory: str = "./data/knowledge_base"):
        self.persist_directory = persist_directory
        self.embeddings = OpenAIEmbeddings(
            api_key=Config.DEEPSEEK_API_KEY,
            base_url="https://api.deepseek.com"
        )
        self.vector_store = None
        self._load_vector_store()
    
    def _load_vector_store(self):
        """加载向量数据库"""
        try:
            self.vector_store = FAISS.load_local(
                self.persist_directory,
                self.embeddings,
                allow_dangerous_deserialization=True
            )
        except Exception:
            self.vector_store = None
    
    def add_document(self, file_path: str):
        """添加文档到知识库"""
        if file_path.endswith('.pdf'):
            loader = PyPDFLoader(file_path)
        else:
            loader = TextLoader(file_path)
        
        documents = loader.load()
        
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200
        )
        splits = text_splitter.split_documents(documents)
        
        if self.vector_store is None:
            self.vector_store = FAISS.from_documents(
                splits,
                self.embeddings
            )
        else:
            self.vector_store.add_documents(splits)
        
        self.vector_store.save_local(self.persist_directory)
    
    def search(self, query: str, k: int = 3) -> List[str]:
        """搜索知识库"""
        if self.vector_store is None:
            return ["知识库为空，请先添加文档"]
        
        docs = self.vector_store.similarity_search(query, k=k)
        return [doc.page_content for doc in docs]
```

#### 智能问答

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough

QA_PROMPT = ChatPromptTemplate.from_template("""
基于以下知识库内容回答问题。如果知识库中没有相关信息，请诚实地告诉用户。

知识库内容：
{context}

问题：{question}

回答：
""")

def create_qa_chain(knowledge_base: KnowledgeBase, llm):
    """创建问答链"""
    def retrieve_context(query: str):
        docs = knowledge_base.search(query, k=3)
        return "\n\n".join(docs)
    
    chain = (
        {
            "context": lambda x: retrieve_context(x["question"]),
            "question": lambda x: x["question"]
        }
        | QA_PROMPT
        | llm
        | StrOutputParser()
    )
    
    return chain
```

## 项目三：自动化任务执行器

### 项目背景
构建一个能够理解自然语言指令并执行自动化任务的智能体。

### 技术栈
- LangChain 1.0
- DeepSeek API
- 任务规划引擎
- 多工具集成

### 核心功能

1. **任务理解**：解析自然语言指令
2. **任务规划**：将复杂任务分解为子任务
3. **工具调用**：执行具体操作
4. **结果验证**：验证任务执行结果

### 关键代码片段

#### 任务规划

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser

PLANNING_PROMPT = ChatPromptTemplate.from_template("""
你是一个任务规划专家。请将用户的任务分解为可执行的子任务。

用户任务：{task}

请以JSON格式返回任务分解结果，格式如下：
{{
    "subtasks": [
        {{
            "id": 1,
            "description": "子任务描述",
            "tool": "需要使用的工具",
            "parameters": {{"参数名": "参数值"}}
        }}
    ]
}}

可用的工具：
- send_email: 发送邮件
- schedule_meeting: 安排会议
- create_document: 创建文档
- search_web: 搜索网络
- calculate: 执行计算

任务分解结果：
""")

class TaskPlanner:
    """任务规划器"""
    
    def __init__(self, llm):
        self.llm = llm
        self.parser = JsonOutputParser()
        self.chain = PLANNING_PROMPT | llm | self.parser
    
    def plan(self, task: str) -> dict:
        """规划任务"""
        try:
            result = self.chain.invoke({"task": task})
            return result
        except Exception as e:
            print(f"任务规划失败：{e}")
            return {"subtasks": []}
```

#### 任务执行

```python
from langchain_core.tools import tool
import smtplib
from email.mime.text import MIMEText
from datetime import datetime, timedelta

@tool
def send_email(to: str, subject: str, body: str) -> str:
    """发送邮件
    
    Args:
        to: 收件人邮箱
        subject: 邮件主题
        body: 邮件内容
    
    Returns:
        发送结果
    """
    return f"邮件已发送至 {to}，主题：{subject}"

@tool
def schedule_meeting(title: str, date: str, time: str, attendees: list) -> str:
    """安排会议
    
    Args:
        title: 会议标题
        date: 日期（YYYY-MM-DD）
        time: 时间（HH:MM）
        attendees: 参会人员列表
    
    Returns:
        安排结果
    """
    return f"会议已安排：{title}，时间：{date} {time}，参会人员：{', '.join(attendees)}"

@tool
def create_document(title: str, content: str) -> str:
    """创建文档
    
    Args:
        title: 文档标题
        content: 文档内容
    
    Returns:
        创建结果
    """
    filename = f"{title}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    with open(f"./documents/{filename}", 'w', encoding='utf-8') as f:
        f.write(content)
    return f"文档已创建：{filename}"

class TaskExecutor:
    """任务执行器"""
    
    def __init__(self):
        self.tools = {
            "send_email": send_email,
            "schedule_meeting": schedule_meeting,
            "create_document": create_document
        }
    
    def execute(self, subtasks: list) -> list:
        """执行子任务"""
        results = []
        for subtask in subtasks:
            tool_name = subtask.get("tool")
            parameters = subtask.get("parameters", {})
            
            if tool_name in self.tools:
                try:
                    result = self.tools[tool_name].invoke(parameters)
                    results.append({
                        "task_id": subtask.get("id"),
                        "status": "success",
                        "result": result
                    })
                except Exception as e:
                    results.append({
                        "task_id": subtask.get("id"),
                        "status": "failed",
                        "error": str(e)
                    })
            else:
                results.append({
                    "task_id": subtask.get("id"),
                    "status": "failed",
                    "error": f"未知工具：{tool_name}"
                })
        
        return results
```

## 学习目标

通过完成这三个项目，你将掌握：

1. **单智能体架构设计**：理解智能体的核心组件和交互方式
2. **工具集成**：学会如何集成和使用各种工具
3. **记忆管理**：掌握对话历史的持久化和管理
4. **任务规划**：理解如何将复杂任务分解为可执行的子任务
5. **错误处理**：学会处理各种异常情况
6. **性能优化**：了解如何优化智能体的响应速度和准确性

## 扩展练习

1. 为智能客服助手添加情感分析功能
2. 为知识管理助手添加知识图谱功能
3. 为任务执行器添加任务优先级调度
4. 实现智能体的自我学习和优化机制
5. 添加日志记录和监控功能

## 参考资源

- [LangChain 1.0 文档](https://python.langchain.com/docs/get_started/introduction)
- [DeepSeek API 文档](https://platform.deepseek.com/api-docs/)
- [FAISS 向量数据库](https://github.com/facebookresearch/faiss)
- [Agent 开发最佳实践](https://python.langchain.com/docs/modules/agents/)
