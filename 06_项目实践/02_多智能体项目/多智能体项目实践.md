# 多智能体项目实践

## 项目概述

本阶段通过三个完整的多智能体项目，深入实践多智能体协同、通信、协作等高级技术。每个项目都基于LangChain 1.0框架，展示不同场景下的多智能体应用。

## 项目一：智能研发团队协作系统

### 项目背景
构建一个模拟软件研发团队的多智能体系统，包含产品经理、架构师、开发工程师、测试工程师等角色，实现自动化的需求分析、架构设计、代码开发和测试流程。

### 技术栈
- LangChain 1.0 (langchain-core, langchain-openai)
- DeepSeek API
- MCP通信协议
- 多智能体协作框架

### 项目结构

```
dev_team_system/
├── config.py                 # 配置文件
├── agents/                   # 智能体定义
│   ├── __init__.py
│   ├── base_agent.py        # 基础智能体类
│   ├── product_manager.py   # 产品经理
│   ├── architect.py         # 架构师
│   ├── developer.py         # 开发工程师
│   └── tester.py            # 测试工程师
├── communication/           # 通信模块
│   ├── __init__.py
│   ├── mcp_protocol.py     # MCP协议实现
│   └── message_bus.py      # 消息总线
├── collaboration/           # 协作模块
│   ├── __init__.py
│   ├── task_distributor.py # 任务分发器
│   └── workflow_engine.py  # 工作流引擎
├── tools/                   # 工具集合
│   ├── __init__.py
│   ├── code_tools.py
│   ├── test_tools.py
│   └── doc_tools.py
└── main.py                  # 主程序入口
```

### 核心代码实现

#### 1. 基础智能体类 (agents/base_agent.py)

```python
from abc import ABC, abstractmethod
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from typing import List, Dict, Optional
from config import Config
from communication.mcp_protocol import MCPMessage
from communication.message_bus import MessageBus

class BaseAgent(ABC):
    """基础智能体类"""
    
    def __init__(self, name: str, role: str, system_prompt: str):
        self.name = name
        self.role = role
        self.system_prompt = system_prompt
        
        self.llm = ChatOpenAI(
            model=Config.DEEPSEEK_MODEL,
            api_key=Config.DEEPSEEK_API_KEY,
            temperature=Config.TEMPERATURE,
            max_tokens=Config.MAX_TOKENS,
            base_url="https://api.deepseek.com"
        )
        
        self.message_bus = MessageBus()
        self.message_bus.register_agent(self.name, self.receive_message)
        
        self.memory: List[Dict] = []
        self.tools = []
    
    @abstractmethod
    def process_task(self, task: str) -> str:
        """处理任务的抽象方法"""
        pass
    
    def receive_message(self, message: MCPMessage):
        """接收消息"""
        self.memory.append({
            "type": "received",
            "from": message.sender,
            "content": message.content,
            "timestamp": message.timestamp
        })
        
        response = self.process_task(message.content)
        
        reply_message = MCPMessage(
            sender=self.name,
            receiver=message.sender,
            content=response,
            message_type="response"
        )
        
        self.message_bus.send_message(reply_message)
    
    def send_message(self, receiver: str, content: str):
        """发送消息"""
        message = MCPMessage(
            sender=self.name,
            receiver=receiver,
            content=content,
            message_type="request"
        )
        
        self.message_bus.send_message(message)
    
    def broadcast_message(self, content: str):
        """广播消息"""
        message = MCPMessage(
            sender=self.name,
            receiver="broadcast",
            content=content,
            message_type="broadcast"
        )
        
        self.message_bus.send_message(message)
    
    def think(self, prompt: str) -> str:
        """思考过程"""
        full_prompt = ChatPromptTemplate.from_messages([
            ("system", self.system_prompt),
            ("human", prompt)
        ])
        
        chain = full_prompt | self.llm
        response = chain.invoke({})
        
        return response.content
```

#### 2. 产品经理智能体 (agents/product_manager.py)

```python
from agents.base_agent import BaseAgent
from typing import Dict, List

PRODUCT_MANAGER_PROMPT = """你是一个经验丰富的产品经理，负责：
1. 分析用户需求，编写产品需求文档（PRD）
2. 与架构师沟通技术可行性
3. 制定产品迭代计划
4. 协调团队成员工作

你的工作风格：
- 注重用户体验
- 清晰表达需求
- 善于沟通协调
- 关注产品细节
"""

class ProductManagerAgent(BaseAgent):
    """产品经理智能体"""
    
    def __init__(self):
        super().__init__(
            name="ProductManager",
            role="产品经理",
            system_prompt=PRODUCT_MANAGER_PROMPT
        )
    
    def process_task(self, task: str) -> str:
        """处理任务"""
        if "需求分析" in task or "PRD" in task:
            return self.analyze_requirements(task)
        elif "技术可行性" in task:
            return self.consult_architect(task)
        else:
            return self.think(task)
    
    def analyze_requirements(self, task: str) -> str:
        """分析需求"""
        prompt = f"""
        请分析以下需求，并编写产品需求文档（PRD）：
        
        需求描述：{task}
        
        PRD应包含：
        1. 产品概述
        2. 用户故事
        3. 功能需求
        4. 非功能需求
        5. 优先级排序
        """
        
        prd = self.think(prompt)
        
        self.send_message("Architect", f"请评估以下PRD的技术可行性：\n{prd}")
        
        return prd
    
    def consult_architect(self, task: str) -> str:
        """咨询架构师"""
        self.send_message("Architect", task)
        return "已将技术可行性评估请求发送给架构师"
```

#### 3. 架构师智能体 (agents/architect.py)

```python
from agents.base_agent import BaseAgent

ARCHITECT_PROMPT = """你是一个资深架构师，负责：
1. 评估技术可行性
2. 设计系统架构
3. 选择技术栈
4. 制定技术规范

你的工作风格：
- 注重系统可扩展性
- 关注性能和安全性
- 善于技术选型
- 编写清晰的技术文档
"""

class ArchitectAgent(BaseAgent):
    """架构师智能体"""
    
    def __init__(self):
        super().__init__(
            name="Architect",
            role="架构师",
            system_prompt=ARCHITECT_PROMPT
        )
    
    def process_task(self, task: str) -> str:
        """处理任务"""
        if "技术可行性" in task:
            return self.evaluate_feasibility(task)
        elif "架构设计" in task:
            return self.design_architecture(task)
        else:
            return self.think(task)
    
    def evaluate_feasibility(self, task: str) -> str:
        """评估技术可行性"""
        prompt = f"""
        请评估以下需求的技术可行性：
        
        需求：{task}
        
        评估应包含：
        1. 技术难点分析
        2. 可行性评估（高/中/低）
        3. 推荐技术方案
        4. 风险提示
        """
        
        evaluation = self.think(prompt)
        
        self.send_message("ProductManager", f"技术可行性评估结果：\n{evaluation}")
        
        return evaluation
    
    def design_architecture(self, task: str) -> str:
        """设计架构"""
        prompt = f"""
        请设计系统架构：
        
        需求：{task}
        
        架构设计应包含：
        1. 系统架构图（文字描述）
        2. 技术栈选择
        3. 模块划分
        4. 接口设计
        5. 数据库设计
        """
        
        architecture = self.think(prompt)
        
        self.send_message("Developer", f"请根据以下架构设计进行开发：\n{architecture}")
        
        return architecture
```

#### 4. 开发工程师智能体 (agents/developer.py)

```python
from agents.base_agent import BaseAgent
from tools.code_tools import write_code, review_code

DEVELOPER_PROMPT = """你是一个经验丰富的开发工程师，负责：
1. 根据架构设计编写代码
2. 进行代码审查
3. 修复bug
4. 编写技术文档

你的工作风格：
- 编写高质量代码
- 注重代码可读性
- 遵循最佳实践
- 编写清晰的注释
"""

class DeveloperAgent(BaseAgent):
    """开发工程师智能体"""
    
    def __init__(self):
        super().__init__(
            name="Developer",
            role="开发工程师",
            system_prompt=DEVELOPER_PROMPT
        )
        self.tools = [write_code, review_code]
    
    def process_task(self, task: str) -> str:
        """处理任务"""
        if "开发" in task or "编写代码" in task:
            return self.write_code(task)
        elif "代码审查" in task:
            return self.review_code(task)
        else:
            return self.think(task)
    
    def write_code(self, task: str) -> str:
        """编写代码"""
        prompt = f"""
        请根据以下需求编写代码：
        
        需求：{task}
        
        要求：
        1. 使用Python语言
        2. 代码结构清晰
        3. 添加必要的注释
        4. 包含错误处理
        """
        
        code = self.think(prompt)
        
        result = write_code.invoke({"code": code})
        
        self.send_message("Tester", f"新代码已提交，请进行测试：\n{task}")
        
        return f"代码已编写并保存：{result}"
    
    def review_code(self, task: str) -> str:
        """代码审查"""
        result = review_code.invoke({"code": task})
        return result
```

#### 5. 测试工程师智能体 (agents/tester.py)

```python
from agents.base_agent import BaseAgent
from tools.test_tools import write_test, run_test

TESTER_PROMPT = """你是一个专业的测试工程师，负责：
1. 编写测试用例
2. 执行测试
3. 报告bug
4. 验证修复

你的工作风格：
- 编写全面的测试用例
- 仔细执行测试
- 准确报告bug
- 验证修复效果
"""

class TesterAgent(BaseAgent):
    """测试工程师智能体"""
    
    def __init__(self):
        super().__init__(
            name="Tester",
            role="测试工程师",
            system_prompt=TESTER_PROMPT
        )
        self.tools = [write_test, run_test]
    
    def process_task(self, task: str) -> str:
        """处理任务"""
        if "测试" in task:
            return self.test_feature(task)
        elif "bug" in task:
            return self.report_bug(task)
        else:
            return self.think(task)
    
    def test_feature(self, task: str) -> str:
        """测试功能"""
        test_code = write_test.invoke({"feature": task})
        
        test_result = run_test.invoke({"test_code": test_code})
        
        if "通过" in test_result:
            self.send_message("Developer", "测试通过，功能正常")
            return "测试通过"
        else:
            self.send_message("Developer", f"测试失败，发现bug：{test_result}")
            return f"测试失败：{test_result}"
    
    def report_bug(self, task: str) -> str:
        """报告bug"""
        bug_report = f"""
        Bug报告：
        - 描述：{task}
        - 严重程度：高
        - 优先级：高
        """
        
        self.send_message("Developer", bug_report)
        return "Bug已报告给开发工程师"
```

#### 6. MCP协议实现 (communication/mcp_protocol.py)

```python
from dataclasses import dataclass
from typing import Dict, Any, Optional
from datetime import datetime
import json

@dataclass
class MCPMessage:
    """MCP消息格式"""
    sender: str
    receiver: str
    content: str
    message_type: str  # request, response, broadcast
    timestamp: str = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now().isoformat()
        if self.metadata is None:
            self.metadata = {}
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            "sender": self.sender,
            "receiver": self.receiver,
            "content": self.content,
            "message_type": self.message_type,
            "timestamp": self.timestamp,
            "metadata": self.metadata
        }
    
    def to_json(self) -> str:
        """转换为JSON字符串"""
        return json.dumps(self.to_dict(), ensure_ascii=False)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MCPMessage':
        """从字典创建"""
        return cls(
            sender=data["sender"],
            receiver=data["receiver"],
            content=data["content"],
            message_type=data["message_type"],
            timestamp=data.get("timestamp"),
            metadata=data.get("metadata", {})
        )
    
    @classmethod
    def from_json(cls, json_str: str) -> 'MCPMessage':
        """从JSON字符串创建"""
        data = json.loads(json_str)
        return cls.from_dict(data)
```

#### 7. 消息总线 (communication/message_bus.py)

```python
from typing import Dict, Callable, List
from communication.mcp_protocol import MCPMessage
import threading
import queue

class MessageBus:
    """消息总线"""
    
    def __init__(self):
        self.agents: Dict[str, Callable] = {}
        self.message_queue = queue.Queue()
        self.running = False
        self.worker_thread = None
    
    def register_agent(self, name: str, handler: Callable[[MCPMessage], None]):
        """注册智能体"""
        self.agents[name] = handler
    
    def unregister_agent(self, name: str):
        """注销智能体"""
        if name in self.agents:
            del self.agents[name]
    
    def send_message(self, message: MCPMessage):
        """发送消息"""
        self.message_queue.put(message)
    
    def start(self):
        """启动消息总线"""
        self.running = True
        self.worker_thread = threading.Thread(target=self._process_messages)
        self.worker_thread.start()
    
    def stop(self):
        """停止消息总线"""
        self.running = False
        if self.worker_thread:
            self.worker_thread.join()
    
    def _process_messages(self):
        """处理消息"""
        while self.running:
            try:
                message = self.message_queue.get(timeout=1)
                self._deliver_message(message)
            except queue.Empty:
                continue
    
    def _deliver_message(self, message: MCPMessage):
        """投递消息"""
        if message.receiver == "broadcast":
            for agent_name, handler in self.agents.items():
                if agent_name != message.sender:
                    try:
                        handler(message)
                    except Exception as e:
                        print(f"消息投递失败：{e}")
        elif message.receiver in self.agents:
            try:
                self.agents[message.receiver](message)
            except Exception as e:
                print(f"消息投递失败：{e}")
        else:
            print(f"未找到接收者：{message.receiver}")
```

#### 8. 主程序 (main.py)

```python
from agents.product_manager import ProductManagerAgent
from agents.architect import ArchitectAgent
from agents.developer import DeveloperAgent
from agents.tester import TesterAgent
from communication.message_bus import MessageBus

def main():
    print("=" * 60)
    print("智能研发团队协作系统")
    print("=" * 60)
    
    message_bus = MessageBus()
    message_bus.start()
    
    pm = ProductManagerAgent()
    architect = ArchitectAgent()
    developer = DeveloperAgent()
    tester = TesterAgent()
    
    print("\n智能研发团队已启动：")
    print(f"- 产品经理：{pm.name}")
    print(f"- 架构师：{architect.name}")
    print(f"- 开发工程师：{developer.name}")
    print(f"- 测试工程师：{tester.name}")
    
    print("\n" + "=" * 60)
    print("输入任务描述，系统将自动分配给合适的智能体处理")
    print("输入 'quit' 退出程序")
    print("=" * 60)
    
    while True:
        user_input = input("\n请输入任务：").strip()
        
        if user_input.lower() in ['quit', 'exit']:
            print("系统关闭中...")
            message_bus.stop()
            break
        
        if not user_input:
            continue
        
        pm.process_task(user_input)
        
        import time
        time.sleep(2)
        
        print("\n任务处理完成")

if __name__ == "__main__":
    main()
```

### 项目特点

1. **角色分工**：不同智能体承担不同职责
2. **协作流程**：自动化工作流程
3. **通信机制**：基于MCP协议的标准化通信
4. **任务分发**：智能任务分配和协调

## 项目二：智能供应链管理系统

### 项目背景
构建一个多智能体供应链管理系统，包含采购、库存、物流、销售等智能体，实现供应链的自动化管理和优化。

### 核心智能体

1. **采购智能体**：负责供应商管理、采购订单生成
2. **库存智能体**：负责库存监控、补货决策
3. **物流智能体**：负责运输调度、物流跟踪
4. **销售智能体**：负责订单处理、需求预测

### 关键代码片段

#### 供应链协调器

```python
from typing import Dict, List
from communication.mcp_protocol import MCPMessage

class SupplyChainCoordinator:
    """供应链协调器"""
    
    def __init__(self, agents: List):
        self.agents = {agent.name: agent for agent in agents}
    
    def process_order(self, order: Dict) -> str:
        """处理订单"""
        print(f"收到订单：{order}")
        
        sales_agent = self.agents["SalesAgent"]
        inventory_agent = self.agents["InventoryAgent"]
        logistics_agent = self.agents["LogisticsAgent"]
        
        stock_check = inventory_agent.check_stock(order["product_id"])
        
        if stock_check["available"]:
            print("库存充足，准备发货")
            
            shipment = logistics_agent.create_shipment(order)
            
            inventory_agent.update_stock(order["product_id"], -order["quantity"])
            
            return f"订单处理成功，运单号：{shipment['tracking_number']}"
        else:
            print("库存不足，触发补货流程")
            
            purchase_order = self.agents["ProcurementAgent"].create_purchase_order(
                product_id=order["product_id"],
                quantity=order["quantity"] * 2
            )
            
            return f"库存不足，已创建采购订单：{purchase_order['order_id']}"
    
    def optimize_supply_chain(self):
        """优化供应链"""
        print("开始供应链优化...")
        
        demand_forecast = self.agents["SalesAgent"].forecast_demand()
        
        inventory_plan = self.agents["InventoryAgent"].plan_inventory(demand_forecast)
        
        procurement_plan = self.agents["ProcurementAgent"].plan_procurement(inventory_plan)
        
        logistics_plan = self.agents["LogisticsAgent"].optimize_routes()
        
        return {
            "demand_forecast": demand_forecast,
            "inventory_plan": inventory_plan,
            "procurement_plan": procurement_plan,
            "logistics_plan": logistics_plan
        }
```

## 项目三：智能金融投资决策系统

### 项目背景
构建一个多智能体金融投资决策系统，包含分析师、风控师、交易员等智能体，实现智能化的投资决策和风险管理。

### 核心智能体

1. **市场分析师**：负责市场分析、趋势预测
2. **风险控制师**：负责风险评估、风险控制
3. **交易执行员**：负责交易执行、仓位管理
4. **投资组合经理**：负责资产配置、投资决策

### 关键代码片段

#### 投资决策流程

```python
class InvestmentDecisionSystem:
    """投资决策系统"""
    
    def __init__(self, agents: List):
        self.agents = {agent.name: agent for agent in agents}
    
    def make_investment_decision(self, market_data: Dict) -> Dict:
        """做出投资决策"""
        print("开始投资决策流程...")
        
        analyst = self.agents["MarketAnalyst"]
        risk_manager = self.agents["RiskController"]
        trader = self.agents["TradeExecutor"]
        portfolio_manager = self.agents["PortfolioManager"]
        
        market_analysis = analyst.analyze_market(market_data)
        
        risk_assessment = risk_manager.assess_risk(market_analysis)
        
        if risk_assessment["risk_level"] == "high":
            print("风险过高，建议观望")
            return {"decision": "hold", "reason": "高风险"}
        
        investment_signals = analyst.generate_signals(market_analysis)
        
        portfolio_allocation = portfolio_manager.allocate_assets(investment_signals)
        
        trade_orders = trader.execute_trades(portfolio_allocation)
        
        return {
            "decision": "trade",
            "market_analysis": market_analysis,
            "risk_assessment": risk_assessment,
            "portfolio_allocation": portfolio_allocation,
            "trade_orders": trade_orders
        }
```

## 学习目标

通过完成这三个多智能体项目，你将掌握：

1. **多智能体架构设计**：理解多智能体系统的架构模式
2. **智能体角色设计**：学会设计不同角色的智能体
3. **协作模式**：掌握各种协作模式（串行、并行、混合）
4. **通信机制**：实现智能体之间的有效通信
5. **任务协调**：学会协调多个智能体的任务执行
6. **冲突解决**：处理智能体之间的冲突和竞争

## 扩展练习

1. 为研发团队系统添加项目管理智能体
2. 为供应链系统添加供应商评估智能体
3. 为投资系统添加新闻分析智能体
4. 实现智能体的动态注册和注销
5. 添加智能体性能监控和优化

## 参考资源

- [LangChain Agents 文档](https://python.langchain.com/docs/modules/agents/)
- [多智能体系统研究](https://en.wikipedia.org/wiki/Multi-agent_system)
- [Agent 协作模式](https://arxiv.org/abs/2308.08155)
- [MCP 协议规范](https://modelcontextprotocol.io/)
