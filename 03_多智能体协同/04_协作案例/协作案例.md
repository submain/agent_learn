# 多智能体协作案例

## 一、案例概述

本案例将实现一个多智能体协作系统，用于完成复杂的数据分析和报告生成任务。系统包含多个智能体，每个智能体负责不同的子任务，通过协作完成整个流程。

### 1. 系统架构

```
+-------------------+     +-------------------+     +-------------------+
|                   |     |                   |     |                   |
|  数据收集智能体    | --> |  数据分析智能体    | --> |  报告生成智能体    |
|                   |     |                   |     |                   |
+-------------------+     +-------------------+     +-------------------+
        ^                         ^                         ^
        |                         |                         |
        v                         v                         v
+-------------------+
|                   |
|  协调管理智能体    |
|                   |
+-------------------+
```

### 2. 智能体角色与职责

| 智能体类型 | 职责 | 能力 |
|----------|------|------|
| 协调管理智能体 | 任务分配、进度监控、结果汇总 | 任务分解、智能体调度、结果整合 |
| 数据收集智能体 | 从各种来源收集数据 | 网络搜索、API调用、数据抓取 |
| 数据分析智能体 | 对收集的数据进行分析 | 统计分析、机器学习、数据可视化 |
| 报告生成智能体 | 根据分析结果生成报告 | 自然语言生成、文档格式转换 |

## 二、系统设计

### 1. 技术选型

- **核心框架**：LangChain 1.0
- **LLM模型**：GPT-3.5-turbo
- **通信协议**：MCP（多智能体通信协议）
- **数据存储**：内存存储（演示用）
- **开发语言**：Python 3.8+

### 2. 系统流程

1. **任务接收**：协调管理智能体接收用户的任务请求
2. **任务分解**：将复杂任务分解为多个子任务
3. **智能体选择**：根据子任务类型选择合适的智能体
4. **任务执行**：各智能体执行分配的子任务
5. **结果返回**：智能体将执行结果返回给协调管理智能体
6. **结果整合**：协调管理智能体整合所有结果
7. **报告生成**：生成最终报告并返回给用户

## 三、代码实现

### 1. 环境准备

```python
# 安装依赖
# pip install langchain langchain_openai python-dotenv

import os
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

# 设置OpenAI API密钥
os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")
```

### 2. 智能体基础类

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.runnables import RunnableWithMessageHistory
from langchain_core.chat_history import InMemoryChatMessageHistory
from langchain_core.output_parsers import StrOutputParser, JsonOutputParser
from typing import Dict, Any, List

# 会话存储
session_store = {}

def get_session_history(session_id: str) -> InMemoryChatMessageHistory:
    """获取会话历史"""
    if session_id not in session_store:
        session_store[session_id] = InMemoryChatMessageHistory()
    return session_store[session_id]

class BaseAgent:
    """智能体基类"""
    def __init__(self, name: str, role: str, system_prompt: str = None):
        self.name = name
        self.role = role
        self.llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.7)
        
        # 创建系统提示
        if not system_prompt:
            system_prompt = f"你是{name}，{role}。请按照要求完成任务。"
        
        # 创建提示模板
        self.prompt = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            MessagesPlaceholder(variable_name="chat_history"),
            ("user", "{input}")
        ])
        
        # 创建基础链
        self.base_chain = self.prompt | self.llm | StrOutputParser()
        
        # 创建带历史记录的链
        self.chain = RunnableWithMessageHistory(
            self.base_chain,
            get_session_history,
            input_messages_key="input",
            history_messages_key="chat_history"
        )
    
    def invoke(self, input: str, session_id: str = None) -> str:
        """调用智能体"""
        if not session_id:
            session_id = self.name
        
        return self.chain.invoke(
            {"input": input},
            config={"configurable": {"session_id": session_id}}
        )
    
    def reset_history(self, session_id: str = None):
        """重置会话历史"""
        if not session_id:
            session_id = self.name
        
        if session_id in session_store:
            del session_store[session_id]
```

### 3. 协调管理智能体

```python
class CoordinatorAgent(BaseAgent):
    """协调管理智能体"""
    def __init__(self):
        super().__init__(
            name="协调管理智能体",
            role="负责任务分配、进度监控和结果汇总的协调者",
            system_prompt="你是协调管理智能体，负责将复杂任务分解为多个子任务，并分配给合适的智能体。请根据任务内容生成一个包含多个子任务的计划。"
        )
        
        # 创建任务分解提示
        self.decomposition_prompt = ChatPromptTemplate.from_messages([
            ("system", "你是任务分解专家，请将用户的复杂任务分解为3-5个具体的子任务，按照执行顺序排列。每个子任务应该有明确的目标和输出要求。请以JSON格式输出，包含'tasks'字段，每个任务包含'name'和'description'字段。"),
            ("user", "{task}")
        ])
        
        # 创建任务分解链
        self.decomposition_chain = self.decomposition_prompt | self.llm | JsonOutputParser()
    
    def decompose_task(self, task: str) -> Dict[str, Any]:
        """分解任务"""
        return self.decomposition_chain.invoke({"task": task})
    
    def coordinate(self, task: str, agents: Dict[str, BaseAgent]) -> Dict[str, Any]:
        """协调多智能体完成任务"""
        results = {
            "original_task": task,
            "coordination_results": []
        }
        
        # 1. 分解任务
        print("=== 协调管理智能体：任务分解 ===")
        decomposed = self.decompose_task(task)
        tasks = decomposed.get("tasks", [])
        print(f"分解后的子任务：{tasks}")
        
        # 2. 分配并执行任务
        print("\n=== 协调管理智能体：任务执行 ===")
        for i, task_item in enumerate(tasks):
            print(f"\n--- 执行子任务 {i+1}/{len(tasks)}: {task_item['name']} ---")
            
            # 根据任务类型选择智能体
            agent_type = self._select_agent_type(task_item)
            if agent_type not in agents:
                print(f"警告：找不到合适的智能体处理任务类型 {agent_type}")
                continue
            
            agent = agents[agent_type]
            print(f"分配给智能体：{agent.name}")
            
            # 执行任务
            result = agent.invoke(task_item['description'])
            print(f"执行结果：{result}")
            
            # 保存结果
            results["coordination_results"].append({
                "task": task_item,
                "agent": agent.name,
                "result": result
            })
        
        # 3. 整合结果
        print("\n=== 协调管理智能体：结果整合 ===")
        final_result = self._integrate_results(results["coordination_results"])
        results["final_result"] = final_result
        print(f"最终结果：{final_result}")
        
        return results
    
    def _select_agent_type(self, task_item: Dict[str, str]) -> str:
        """根据任务类型选择智能体"""
        task_name = task_item["name"].lower()
        
        if any(keyword in task_name for keyword in ["收集", "获取", "搜索"]):
            return "data_collector"
        elif any(keyword in task_name for keyword in ["分析", "统计", "处理"]):
            return "data_analyzer"
        elif any(keyword in task_name for keyword in ["报告", "总结", "生成"]):
            return "report_generator"
        else:
            return "data_collector"  # 默认使用数据收集智能体
    
    def _integrate_results(self, results: List[Dict[str, Any]]) -> str:
        """整合多个智能体的执行结果"""
        # 构建整合提示
        integration_prompt = f"请根据以下子任务执行结果，生成一份完整的最终报告：\n\n"
        for i, result in enumerate(results):
            integration_prompt += f"子任务 {i+1}: {result['task']['name']}\n"
            integration_prompt += f"执行结果：{result['result']}\n\n"
        
        # 调用智能体生成最终报告
        return self.invoke(integration_prompt)
```

### 4. 数据收集智能体

```python
class DataCollectorAgent(BaseAgent):
    """数据收集智能体"""
    def __init__(self):
        super().__init__(
            name="数据收集智能体",
            role="负责从各种来源收集数据的专家",
            system_prompt="你是数据收集专家，擅长从网络、API和数据库中收集信息。请根据任务要求，详细描述需要收集的数据内容和来源。"
        )
    
    def collect_data(self, task: str) -> str:
        """收集数据"""
        # 模拟数据收集过程
        return self.invoke(f"请详细描述如何收集以下任务所需的数据：{task}\n\n请包括：1. 数据类型和内容；2. 数据来源；3. 收集方法；4. 预期结果。")
```

### 5. 数据分析智能体

```python
class DataAnalyzerAgent(BaseAgent):
    """数据分析智能体"""
    def __init__(self):
        super().__init__(
            name="数据分析智能体",
            role="负责数据分析和可视化的专家",
            system_prompt="你是数据分析专家，擅长统计分析、机器学习和数据可视化。请根据提供的数据，进行深入分析并生成有价值的见解。"
        )
    
    def analyze_data(self, data: str) -> str:
        """分析数据"""
        return self.invoke(f"请对以下数据进行深入分析：{data}\n\n请包括：1. 数据概览；2. 关键指标；3. 趋势分析；4. 洞察和建议。")
```

### 6. 报告生成智能体

```python
class ReportGeneratorAgent(BaseAgent):
    """报告生成智能体"""
    def __init__(self):
        super().__init__(
            name="报告生成智能体",
            role="负责生成结构化报告的专家",
            system_prompt="你是报告生成专家，擅长将复杂信息整理成结构化、易读的报告。请根据提供的内容，生成一份专业的报告。"
        )
    
    def generate_report(self, content: str) -> str:
        """生成报告"""
        return self.invoke(f"请根据以下内容生成一份结构化的报告：{content}\n\n报告应包括：1. 标题；2. 摘要；3. 目录；4. 详细内容；5. 结论和建议。")
```

### 7. 系统集成

```python
class MultiAgentSystem:
    """多智能体系统"""
    def __init__(self):
        # 创建各种智能体
        self.agents = {
            "coordinator": CoordinatorAgent(),
            "data_collector": DataCollectorAgent(),
            "data_analyzer": DataAnalyzerAgent(),
            "report_generator": ReportGeneratorAgent()
        }
    
    def run_task(self, task: str) -> Dict[str, Any]:
        """运行多智能体系统完成任务"""
        # 调用协调管理智能体
        return self.agents["coordinator"].coordinate(task, self.agents)
    
    def get_agent(self, agent_type: str) -> BaseAgent:
        """获取智能体"""
        return self.agents.get(agent_type)
    
    def list_agents(self) -> List[str]:
        """列出所有智能体"""
        return list(self.agents.keys())
```

### 8. 测试系统

```python
if __name__ == "__main__":
    # 创建多智能体系统
    mas = MultiAgentSystem()
    
    # 测试任务
    task = "请分析2025年智能体开发的最新趋势，包括技术发展、市场规模、应用场景等方面，并生成一份完整的分析报告。"
    
    print("=== 多智能体协作系统测试 ===")
    print(f"任务：{task}")
    
    # 运行任务
    results = mas.run_task(task)
    
    # 打印最终结果
    print("\n=== 最终报告 ===")
    print(results["final_result"])
    
    # 保存结果到文件
    with open("collaboration_result.txt", "w", encoding="utf-8") as f:
        f.write("=== 多智能体协作系统结果 ===\n")
        f.write(f"原始任务：{results['original_task']}\n\n")
        f.write("=== 协调结果 ===\n")
        for i, res in enumerate(results['coordination_results']):
            f.write(f"\n--- 子任务 {i+1} ---\n")
            f.write(f"任务：{res['task']['name']}\n")
            f.write(f"描述：{res['task']['description']}\n")
            f.write(f"智能体：{res['agent']}\n")
            f.write(f"结果：{res['result']}\n")
        f.write("\n=== 最终报告 ===\n")
        f.write(results['final_result'])
    
    print("\n结果已保存到 collaboration_result.txt 文件")
```

## 四、扩展功能

### 1. 添加新的智能体类型

```python
class NewAgentType(BaseAgent):
    """新的智能体类型"""
    def __init__(self):
        super().__init__(
            name="新智能体",
            role="新智能体的职责描述"
        )
    
    def custom_method(self, data: str) -> str:
        """自定义方法"""
        return self.invoke(f"处理：{data}")

# 添加到多智能体系统
mas = MultiAgentSystem()
mas.agents["new_agent_type"] = NewAgentType()
```

### 2. 实现更复杂的智能体选择逻辑

```python
def _select_agent_type(self, task_item: Dict[str, str]) -> str:
    """改进的智能体选择逻辑"""
    task_name = task_item["name"].lower()
    task_desc = task_item["description"].lower()
    
    # 更复杂的匹配逻辑
    if any(keyword in task_name or keyword in task_desc for keyword in ["收集", "获取", "搜索"]):
        return "data_collector"
    elif any(keyword in task_name or keyword in task_desc for keyword in ["分析", "统计", "处理"]):
        return "data_analyzer"
    elif any(keyword in task_name or keyword in task_desc for keyword in ["报告", "总结", "生成"]):
        return "report_generator"
    elif any(keyword in task_name or keyword in task_desc for keyword in ["设计", "创建", "开发"]):
        return "design_agent"
    else:
        return "coordinator"  # 默认使用协调智能体
```

### 3. 添加结果验证和反馈机制

```python
def validate_result(self, task: Dict[str, Any], result: str) -> bool:
    """验证结果是否符合要求"""
    # 创建验证提示
    validation_prompt = ChatPromptTemplate.from_messages([
        ("system", "你是结果验证专家，请判断以下结果是否符合任务要求。请回答'是'或'否'。"),
        ("user", "任务：{task}\n结果：{result}")
    ])
    
    validation_chain = validation_prompt | self.llm | StrOutputParser()
    
    validation_result = validation_chain.invoke({
        "task": task, "result": result
    })
    
    return validation_result.strip().lower() == "是"
```

## 五、性能优化

### 1. 并行执行任务

```python
import concurrent.futures

def coordinate(self, task: str, agents: Dict[str, BaseAgent]) -> Dict[str, Any]:
    # ... 之前的代码 ...
    
    # 并行执行任务
    print("\n=== 协调管理智能体：并行任务执行 ===")
    
    def execute_task(task_item):
        agent_type = self._select_agent_type(task_item)
        if agent_type not in agents:
            return None
        
        agent = agents[agent_type]
        result = agent.invoke(task_item['description'])
        
        return {
            "task": task_item,
            "agent": agent.name,
            "result": result
        }
    
    # 使用线程池并行执行任务
    with concurrent.futures.ThreadPoolExecutor(max_workers=len(tasks)) as executor:
        # 提交所有任务
        future_to_task = {
            executor.submit(execute_task, task_item): task_item
            for task_item in tasks
        }
        
        # 收集结果
        for future in concurrent.futures.as_completed(future_to_task):
            result = future.result()
            if result:
                results["coordination_results"].append(result)
    
    # ... 之后的代码 ...
```

### 2. 缓存机制

```python
from functools import lru_cache

class CachedAgent(BaseAgent):
    """带缓存的智能体"""
    def __init__(self, name: str, role: str, system_prompt: str = None):
        super().__init__(name, role, system_prompt)
    
    @lru_cache(maxsize=128)
    def invoke_with_cache(self, input: str, session_id: str = None) -> str:
        """带缓存的调用"""
        return self.invoke(input, session_id)
```

## 六、总结

本案例实现了一个基于LangChain 1.0的多智能体协作系统，包括：

1. **智能体设计**：创建了协调管理、数据收集、数据分析和报告生成四种智能体
2. **任务分解**：实现了复杂任务的自动分解
3. **智能体协作**：通过协调管理智能体实现了多智能体的协作
4. **结果整合**：将多个智能体的执行结果整合为最终报告
5. **可扩展性**：系统设计支持添加新的智能体类型和功能

通过这个案例，你可以学习到：

- 如何设计和实现多智能体系统
- 如何使用LangChain 1.0构建智能体
- 如何实现智能体之间的通信和协作
- 如何优化多智能体系统的性能

这个系统可以进一步扩展，添加更多智能体类型、更复杂的协作模式和更高级的功能，如自适应任务分配、动态智能体创建等。

## 七、进一步学习资源

1. **LangChain官方文档**：https://python.langchain.com/docs/get_started/introduction
2. **多智能体系统论文**：《Multi-Agent Systems: Algorithmic, Game-Theoretic, and Logical Foundations》
3. **MCP协议规范**：https://github.com/multi-agent-protocol/mcp
4. **智能体开发框架**：AgentGPT、AutoGPT等
5. **开源智能体项目**：LangChain Agents、AutoGen等

通过不断学习和实践，你可以逐步掌握智能体开发的核心技术，成为一名优秀的智能体开发工程师。