# 多智能体系统基础

## 一、多智能体系统概述

### 1. 什么是多智能体系统

多智能体系统（Multi-Agent System，MAS）是由多个智能体组成的系统，这些智能体之间可以相互交互、协作和竞争，以完成复杂的任务。多智能体系统具有以下特点：

- **分布性**：智能体分布在不同的位置或进程中
- **自主性**：每个智能体具有独立的决策能力
- **异构性**：智能体可以具有不同的能力和结构
- **协作性**：智能体之间可以相互协作完成任务
- **适应性**：系统可以适应环境的变化

### 2. 多智能体系统的优势

- **解决复杂问题**：通过分工协作解决单智能体难以处理的复杂问题
- **提高鲁棒性**：单个智能体故障不会导致整个系统崩溃
- **增强适应性**：系统可以根据环境变化调整协作策略
- **提高效率**：并行处理多个子任务
- **降低成本**：可以重用现有的智能体组件

### 3. 多智能体系统的应用领域

- **机器人协作**：多个机器人协同完成任务
- **交通管理**：智能交通系统
- **供应链管理**：智能物流和供应链优化
- **游戏AI**：游戏中的非玩家角色协同
- **金融市场模拟**：模拟金融市场中的多个参与者
- **医疗诊断**：多个专家系统协同诊断

## 二、多智能体系统的架构

### 1. 中心化架构

- **特点**：存在一个中心智能体，负责协调其他智能体
- **优势**：控制简单，协调效率高
- **劣势**：中心智能体成为单点故障，扩展性差
- **适用场景**：小规模系统，任务简单明确

### 2. 去中心化架构

- **特点**：没有中心智能体，智能体之间直接通信
- **优势**：鲁棒性强，扩展性好
- **劣势**：协调复杂，可能出现冲突
- **适用场景**：大规模系统，动态环境

### 3. 混合架构

- **特点**：结合中心化和去中心化的优点
- **优势**：灵活性高，适应性强
- **劣势**：设计复杂
- **适用场景**：中等规模系统，复杂任务

### 4. 分层架构

- **特点**：智能体按照功能或层次组织
- **优势**：模块化强，易于管理
- **劣势**：层次间通信开销大
- **适用场景**：功能复杂的系统

## 三、基于LangChain 1.0的多智能体系统

### 1. LangChain 1.0的多智能体组件

LangChain 1.0提供了多种多智能体开发组件：

- **AgentExecutor**：智能体执行器
- **BaseMultiAgentExecutor**：多智能体执行器基类
- **Runnable**：可组合的执行单元
- **Message**：智能体间通信的消息格式

### 2. 简单的多智能体系统实现

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.runnables import RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_core.tools import tool

# 定义工具
@tool
def search(query: str) -> str:
    """搜索网络获取信息。
    
    Args:
        query: 搜索查询字符串
    
    Returns:
        搜索结果的文本摘要
    """
    return f"搜索结果：关于{query}的信息..."

@tool
def calculate(expression: str) -> str:
    """执行数学计算。
    
    Args:
        expression: 要计算的数学表达式
    
    Returns:
        计算结果
    """
    try:
        result = eval(expression)
        return f"计算结果：{expression} = {result}"
    except Exception as e:
        return f"计算错误：{str(e)}"

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 创建不同角色的智能体
class Agent:
    def __init__(self, name: str, role: str, tools: list = None):
        self.name = name
        self.role = role
        
        # 创建提示模板
        prompt = ChatPromptTemplate.from_messages([
            ("system", f"你是{name}，{role}"),
            MessagesPlaceholder(variable_name="chat_history"),
            ("user", "{input}")
        ])
        
        # 创建智能体
        if tools:
            agent = create_tool_calling_agent(llm, tools, prompt)
            self.executor = AgentExecutor(agent=agent, tools=tools, verbose=True)
        else:
            # 没有工具的智能体
            chain = prompt | llm | StrOutputParser()
            self.executor = chain
    
    def invoke(self, input: str, chat_history: list = None) -> str:
        """调用智能体"""
        if hasattr(self.executor, 'invoke'):
            if isinstance(self.executor, AgentExecutor):
                return self.executor.invoke({"input": input, "chat_history": chat_history or []})
            else:
                return self.executor.invoke({"input": input})
        return "智能体调用失败"

# 创建多智能体系统
class MultiAgentSystem:
    def __init__(self):
        self.agents = {}
    
    def add_agent(self, agent: Agent):
        """添加智能体"""
        self.agents[agent.name] = agent
    
    def get_agent(self, name: str) -> Agent:
        """获取智能体"""
        return self.agents.get(name)
    
    def list_agents(self) -> list:
        """列出所有智能体"""
        return list(self.agents.keys())
    
    def run_agent(self, name: str, input: str, chat_history: list = None) -> str:
        """运行指定智能体"""
        agent = self.get_agent(name)
        if agent:
            return agent.invoke(input, chat_history)
        return f"智能体 {name} 不存在"
    
    def run_collaboration(self, task: str, agent_chain: list) -> dict:
        """多智能体协作完成任务"""
        results = {}
        chat_history = []
        
        # 按照指定顺序运行智能体
        for agent_name in agent_chain:
            agent = self.get_agent(agent_name)
            if agent:
                result = agent.invoke(task, chat_history)
                results[agent_name] = result
                
                # 更新聊天历史
                if isinstance(result, dict) and "output" in result:
                    chat_history.append(("assistant", result["output"]))
                else:
                    chat_history.append(("assistant", str(result)))
            else:
                results[agent_name] = f"智能体 {agent_name} 不存在"
        
        return results

# 测试多智能体系统
if __name__ == "__main__":
    # 创建智能体
    search_agent = Agent(
        name="搜索专家",
        role="擅长搜索和获取信息",
        tools=[search]
    )
    
    calculator_agent = Agent(
        name="计算专家",
        role="擅长数学计算",
        tools=[calculate]
    )
    
    planner_agent = Agent(
        name="规划专家",
        role="擅长任务规划和分解"
    )
    
    # 创建多智能体系统
    mas = MultiAgentSystem()
    mas.add_agent(search_agent)
    mas.add_agent(calculator_agent)
    mas.add_agent(planner_agent)
    
    # 列出智能体
    print(f"已添加的智能体：{mas.list_agents()}")
    
    # 测试单个智能体
    print("\n=== 测试搜索专家 ===")
    search_result = mas.run_agent("搜索专家", "智能体开发的最新趋势")
    print(f"搜索专家结果：{search_result}")
    
    print("\n=== 测试计算专家 ===")
    calculate_result = mas.run_agent("计算专家", "1+2*3*4")
    print(f"计算专家结果：{calculate_result}")
    
    # 测试多智能体协作
    print("\n=== 测试多智能体协作 ===")
    task = "请搜索智能体开发的最新趋势，然后计算1+2*3*4的结果"
    collaboration_result = mas.run_collaboration(task, ["规划专家", "搜索专家", "计算专家"])
    
    print("协作结果：")
    for agent_name, result in collaboration_result.items():
        print(f"{agent_name}：{result}")
