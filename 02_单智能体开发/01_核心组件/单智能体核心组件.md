# 单智能体核心组件

## 一、智能体的核心架构

一个完整的智能体通常包含以下核心组件：

1. **感知模块（Perception）**：负责获取和处理环境信息
2. **决策模块（Decision）**：负责制定行动计划
3. **执行模块（Execution）**：负责执行行动计划
4. **记忆模块（Memory）**：负责存储和检索信息
5. **通信模块（Communication）**：负责与其他智能体或系统交互

## 二、感知模块设计

### 1. 感知模块的功能

感知模块的主要功能是获取和处理环境信息，为决策模块提供输入。它需要处理以下类型的信息：

- **文本输入**：用户的自然语言输入
- **结构化数据**：API返回的JSON数据、数据库查询结果等
- **非结构化数据**：图像、音频等（需要多模态模型支持）
- **环境状态**：系统的运行状态、资源使用情况等

### 2. 感知模块的实现

```python
class PerceptionModule:
    def __init__(self):
        # 初始化感知模块
        self.processors = {
            'text': self._process_text,
            'structured': self._process_structured,
            'unstructured': self._process_unstructured
        }
    
    def _process_text(self, input_data):
        """处理文本输入"""
        # 去除多余空格和换行
        processed_text = input_data.strip()
        return {
            'type': 'text',
            'content': processed_text,
            'length': len(processed_text)
        }
    
    def _process_structured(self, input_data):
        """处理结构化数据"""
        # 验证数据格式
        if isinstance(input_data, (dict, list)):
            return {
                'type': 'structured',
                'content': input_data,
                'size': len(input_data) if isinstance(input_data, list) else len(input_data.keys())
            }
        else:
            raise ValueError("结构化数据必须是字典或列表类型")
    
    def _process_unstructured(self, input_data):
        """处理非结构化数据"""
        # 这里可以添加图像、音频等处理逻辑
        return {
            'type': 'unstructured',
            'content': input_data,
            'metadata': {
                'processed': False
            }
        }
    
    def perceive(self, input_data, data_type='text'):
        """感知环境信息"""
        if data_type in self.processors:
            return self.processors[data_type](input_data)
        else:
            raise ValueError(f"不支持的数据类型: {data_type}")
```

### 3. 感知模块的测试

```python
# 测试感知模块
perception = PerceptionModule()

# 测试文本处理
text_result = perception.perceive(" 你好，我是智能体！  ")
print("文本处理结果:", text_result)

# 测试结构化数据处理
structured_data = {"name": "智能体", "version": "1.0"}
structured_result = perception.perceive(structured_data, data_type='structured')
print("结构化数据处理结果:", structured_result)
```

## 三、决策模块设计

### 1. 决策模块的功能

决策模块是智能体的核心，负责根据感知模块提供的信息和记忆模块的历史信息，制定行动计划。它需要具备以下能力：

- **目标分析**：理解用户的目标和需求
- **任务分解**：将复杂任务分解为简单子任务
- **计划生成**：生成详细的执行计划
- **资源分配**：分配执行任务所需的资源

### 2. 基于LLM的决策模块

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

class DecisionModule:
    def __init__(self, api_key):
        # 初始化LLM
        self.llm = ChatOpenAI(api_key=api_key, model="gpt-3.5-turbo")
        
        # 创建决策提示模板
        self.decision_template = ChatPromptTemplate.from_template(
            """你是一个智能体的决策模块，请根据当前状态、目标和历史记录，生成详细的执行计划。

当前状态：{current_state}
目标：{goal}
历史记录：{history}

请按照以下格式生成执行计划：
1. 第一步：[具体行动]
2. 第二步：[具体行动]
...

执行计划："""
        )
        
        # 创建链
        self.chain = self.decision_template | self.llm | StrOutputParser()
    
    def make_decision(self, current_state, goal, history=None):
        """制定决策和执行计划"""
        if history is None:
            history = "无"
        
        # 调用链生成计划
        plan = self.chain.invoke({
            "current_state": current_state,
            "goal": goal,
            "history": history
        })
        
        # 解析计划
        parsed_plan = self._parse_plan(plan)
        
        return {
            'raw_plan': plan,
            'parsed_plan': parsed_plan,
            'timestamp': self._get_current_timestamp()
        }
    
    def _parse_plan(self, plan_text):
        """解析LLM生成的计划"""
        steps = []
        lines = plan_text.strip().split('\n')
        for line in lines:
            if line.strip():
                # 提取步骤编号和内容
                if '.' in line:
                    step_parts = line.split('.', 1)
                    if len(step_parts) == 2:
                        step_num = step_parts[0].strip()
                        step_content = step_parts[1].strip()
                        steps.append({
                            'step': step_num,
                            'action': step_content
                        })
        return steps
    
    def _get_current_timestamp(self):
        """获取当前时间戳"""
        from datetime import datetime
        return datetime.now().isoformat()
```

### 3. 决策模块的测试

```python
# 测试决策模块
import os
from dotenv import load_dotenv

load_dotenv()
decision = DecisionModule(api_key=os.getenv("OPENAI_API_KEY"))

# 测试决策制定
current_state = "当前智能体处于空闲状态，可使用的工具有：搜索引擎、计算器、文件操作"
goal = "请帮我查找Python智能体开发的最新趋势，并生成一份报告"
history = "之前执行过类似的搜索任务，结果保存在report.md文件中"

decision_result = decision.make_decision(current_state, goal, history)
print("决策结果:")
print(f"原始计划: {decision_result['raw_plan']}")
print(f"解析后的计划: {decision_result['parsed_plan']}")
```

## 四、执行模块设计

### 1. 执行模块的功能

执行模块负责执行决策模块生成的计划，它需要具备以下能力：

- **工具调用**：调用外部工具和API
- **动作执行**：执行具体的动作
- **结果处理**：处理执行结果
- **异常处理**：处理执行过程中的异常

### 2. 执行模块的实现

```python
class ExecutionModule:
    def __init__(self):
        # 初始化执行模块
        self.tools = {
            'search': self._execute_search,
            'calculate': self._execute_calculate,
            'write_file': self._execute_write_file
        }
    
    def _execute_search(self, query):
        """执行搜索操作"""
        # 这里可以集成真实的搜索引擎API，如Google Search API
        print(f"正在搜索: {query}")
        # 模拟搜索结果
        return {
            'status': 'success',
            'result': f"搜索结果：关于{query}的信息...",
            'metadata': {
                'search_time': 1.2,
                'result_count': 10
            }
        }
    
    def _execute_calculate(self, expression):
        """执行计算操作"""
        try:
            # 使用eval执行简单计算，注意安全风险
            result = eval(expression)
            return {
                'status': 'success',
                'result': f"计算结果：{expression} = {result}",
                'metadata': {
                    'expression': expression
                }
            }
        except Exception as e:
            return {
                'status': 'error',
                'result': f"计算错误：{str(e)}",
                'metadata': {
                    'expression': expression
                }
            }
    
    def _execute_write_file(self, file_path, content):
        """执行文件写入操作"""
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return {
                'status': 'success',
                'result': f"文件已成功写入：{file_path}",
                'metadata': {
                    'file_path': file_path,
                    'content_length': len(content)
                }
            }
        except Exception as e:
            return {
                'status': 'error',
                'result': f"文件写入错误：{str(e)}",
                'metadata': {
                    'file_path': file_path
                }
            }
    
    def execute(self, action, params=None):
        """执行动作"""
        if params is None:
            params = {}
        
        # 提取动作类型和参数
        if isinstance(action, dict):
            action_type = action.get('type', '')
            action_params = action.get('params', {})
        else:
            # 简单动作处理
            action_type = action.split()[0].lower()
            action_params = {'query': ' '.join(action.split()[1:])}
        
        # 合并参数
        action_params.update(params)
        
        # 执行动作
        if action_type in self.tools:
            return self.tools[action_type](**action_params)
        else:
            return {
                'status': 'error',
                'result': f"不支持的动作类型: {action_type}",
                'metadata': {}
            }
```

### 3. 执行模块的测试

```python
# 测试执行模块
execution = ExecutionModule()

# 测试搜索执行
search_result = execution.execute('search 智能体开发趋势')
print("搜索执行结果:", search_result)

# 测试计算执行
calculate_result = execution.execute('calculate 1+2*3')
print("计算执行结果:", calculate_result)

# 测试文件写入执行
write_result = execution.execute('write_file', params={'file_path': 'test.txt', 'content': '测试内容'})
print("文件写入执行结果:", write_result)
```

## 五、记忆模块设计

### 1. 记忆模块的功能

记忆模块负责存储和检索智能体的信息，它需要具备以下能力：

- **短期记忆**：存储最近的交互和状态信息
- **长期记忆**：存储长期的知识和经验
- **记忆检索**：根据需求检索相关记忆
- **记忆更新**：更新和维护记忆内容

### 2. 基于向量数据库的记忆模块

```python
from langchain_openai import OpenAIEmbeddings
from langchain_chroma import Chroma

class MemoryModule:
    def __init__(self, api_key, persist_directory="./memory_db"):
        # 初始化向量数据库
        self.embeddings = OpenAIEmbeddings(api_key=api_key)
        self.vectorstore = Chroma(
            embedding_function=self.embeddings,
            persist_directory=persist_directory
        )
        
        # 短期记忆（内存中）
        self.short_term_memory = []
        self.max_short_term_memory = 100
    
    def add_memory(self, content, memory_type='short'):
        """添加记忆"""
        if memory_type == 'short':
            # 添加到短期记忆
            self.short_term_memory.append({
                'content': content,
                'timestamp': self._get_current_timestamp()
            })
            
            # 限制短期记忆大小
            if len(self.short_term_memory) > self.max_short_term_memory:
                self.short_term_memory.pop(0)
        else:
            # 添加到长期记忆（向量数据库）
            self.vectorstore.add_texts([content])
    
    def retrieve_memory(self, query, k=5, memory_type='all'):
        """检索记忆"""
        results = []
        
        if memory_type in ['short', 'all']:
            # 从短期记忆中检索（简单匹配）
            for memory in self.short_term_memory:
                if query.lower() in memory['content'].lower():
                    results.append({
                        'content': memory['content'],
                        'type': 'short',
                        'timestamp': memory['timestamp']
                    })
        
        if memory_type in ['long', 'all']:
            # 从长期记忆中检索（向量相似性匹配）
            docs = self.vectorstore.similarity_search(query, k=k)
            for doc in docs:
                results.append({
                    'content': doc.page_content,
                    'type': 'long',
                    'timestamp': self._get_current_timestamp()
                })
        
        return results
    
    def clear_short_term_memory(self):
        """清除短期记忆"""
        self.short_term_memory = []
    
    def _get_current_timestamp(self):
        """获取当前时间戳"""
        from datetime import datetime
        return datetime.now().isoformat()
```

### 3. 记忆模块的测试

```python
# 测试记忆模块
import os
from dotenv import load_dotenv

load_dotenv()
memory = MemoryModule(api_key=os.getenv("OPENAI_API_KEY"))

# 测试添加记忆
memory.add_memory("用户询问了智能体开发的趋势", memory_type='short')
memory.add_memory("Python是智能体开发的主要语言之一", memory_type='long')
memory.add_memory("LangChain是常用的智能体开发框架", memory_type='long')

# 测试检索记忆
retrieved_memories = memory.retrieve_memory("智能体开发", k=3)
print("检索到的记忆:")
for mem in retrieved_memories:
    print(f"类型: {mem['type']}, 内容: {mem['content']}")
```

## 六、通信模块设计

### 1. 通信模块的功能

通信模块负责智能体与其他智能体或系统的交互，它需要具备以下能力：

- **消息发送**：发送消息给其他智能体或系统
- **消息接收**：接收来自其他智能体或系统的消息
- **消息处理**：处理接收到的消息
- **协议转换**：在不同通信协议之间转换

### 2. 通信模块的实现

```python
class CommunicationModule:
    def __init__(self):
        # 初始化通信模块
        self.connections = {}
    
    def connect(self, agent_id, connection_info):
        """建立与其他智能体的连接"""
        self.connections[agent_id] = connection_info
        return {
            'status': 'success',
            'message': f"已成功连接到智能体: {agent_id}"
        }
    
    def disconnect(self, agent_id):
        """断开与其他智能体的连接"""
        if agent_id in self.connections:
            del self.connections[agent_id]
            return {
                'status': 'success',
                'message': f"已成功断开与智能体: {agent_id} 的连接"
            }
        else:
            return {
                'status': 'error',
                'message': f"未找到智能体: {agent_id}"
            }
    
    def send_message(self, recipient_id, message, message_type='text'):
        """发送消息"""
        if recipient_id in self.connections:
            # 这里可以实现真实的消息发送逻辑
            print(f"向智能体 {recipient_id} 发送消息: {message}")
            return {
                'status': 'success',
                'message': f"消息已发送到智能体: {recipient_id}"
            }
        else:
            return {
                'status': 'error',
                'message': f"未找到智能体: {recipient_id}"
            }
    
    def receive_message(self, sender_id, message):
        """接收消息"""
        # 这里可以实现真实的消息接收逻辑
        print(f"从智能体 {sender_id} 接收消息: {message}")
        return {
            'sender': sender_id,
            'message': message,
            'timestamp': self._get_current_timestamp()
        }
    
    def _get_current_timestamp(self):
        """获取当前时间戳"""
        from datetime import datetime
        return datetime.now().isoformat()
```

### 3. 通信模块的测试

```python
# 测试通信模块
communication = CommunicationModule()

# 测试连接
connect_result = communication.connect("agent_1", {"url": "http://localhost:8000"})
print("连接结果:", connect_result)

# 测试发送消息
send_result = communication.send_message("agent_1", "你好，我是另一个智能体！")
print("发送消息结果:", send_result)

# 测试接收消息
receive_result = communication.receive_message("agent_1", "你好，很高兴认识你！")
print("接收消息结果:", receive_result)

# 测试断开连接
disconnect_result = communication.disconnect("agent_1")
print("断开连接结果:", disconnect_result)
```

## 七、智能体核心组件的集成

### 1. 智能体的整体架构

将上述核心组件集成到一个完整的智能体中：

```python
class Agent:
    def __init__(self, api_key, name="智能体"):
        # 初始化智能体
        self.name = name
        self.api_key = api_key
        
        # 初始化各个模块
        self.perception = PerceptionModule()
        self.decision = DecisionModule(api_key=api_key)
        self.execution = ExecutionModule()
        self.memory = MemoryModule(api_key=api_key)
        self.communication = CommunicationModule()
        
        # 智能体状态
        self.state = "idle"  # idle, working, error
    
    def run(self, input_data, data_type='text'):
        """智能体运行主循环"""
        try:
            # 1. 感知阶段
            self.state = "perceiving"
            perceived_info = self.perception.perceive(input_data, data_type)
            
            # 2. 更新记忆
            self.memory.add_memory(f"感知到的信息: {perceived_info['content']}", memory_type='short')
            
            # 3. 决策阶段
            self.state = "deciding"
            current_state = f"当前状态: {self.state}, 感知到的信息: {perceived_info['content']}"
            goal = perceived_info['content']  # 简单将感知到的信息作为目标
            history = f"最近的记忆: {[mem['content'] for mem in self.memory.short_term_memory[-5:]]}"
            
            decision_result = self.decision.make_decision(current_state, goal, history)
            
            # 4. 执行阶段
            self.state = "executing"
            execution_results = []
            
            for step in decision_result['parsed_plan']:
                execution_result = self.execution.execute(step['action'])
                execution_results.append({
                    'step': step['step'],
                    'action': step['action'],
                    'result': execution_result
                })
                
                # 更新记忆
                self.memory.add_memory(f"执行步骤 {step['step']}: {step['action']}, 结果: {execution_result['result']}", memory_type='short')
            
            # 5. 完成任务
            self.state = "idle"
            
            # 6. 生成最终结果
            final_result = {
                'agent_name': self.name,
                'input': input_data,
                'perceived_info': perceived_info,
                'decision_result': decision_result,
                'execution_results': execution_results,
                'final_state': self.state
            }
            
            return final_result
            
        except Exception as e:
            self.state = "error"
            return {
                'agent_name': self.name,
                'input': input_data,
                'error': str(e),
                'final_state': self.state
            }
```

### 2. 完整智能体的测试

```python
# 测试完整智能体
import os
from dotenv import load_dotenv

load_dotenv()

# 创建智能体实例
agent = Agent(api_key=os.getenv("OPENAI_API_KEY"), name="测试智能体")

# 运行智能体
result = agent.run("请帮我计算1+2*3的结果")

# 打印结果
print(f"智能体名称: {result['agent_name']}")
print(f"输入: {result['input']}")
print(f"感知到的信息: {result['perceived_info']['content']}")
print(f"决策结果: {result['decision_result']['raw_plan']}")
print("执行结果:")
for execution in result['execution_results']:
    print(f"  步骤 {execution['step']}: {execution['action']} -> {execution['result']['result']}")
print(f"最终状态: {result['final_state']}")
```

## 八、总结

智能体的核心组件包括感知模块、决策模块、执行模块、记忆模块和通信模块。这些组件协同工作，使智能体能够感知环境、做出决策、执行动作、存储记忆并与其他智能体交互。

在后续的学习中，我们将深入学习智能体的自主规划、工具使用、状态管理等高级功能，逐步构建更复杂、更强大的智能体系统。
