# 智能体工具使用

## 一、工具使用概述

### 1. 什么是智能体工具使用

智能体工具使用是指智能体能够自主选择和调用外部工具或API来完成任务的能力。这是智能体扩展其能力范围的关键机制，使智能体能够：

- 获取实时信息（如天气、新闻、股票价格等）
- 执行计算和数据分析
- 与外部系统交互
- 操作文件和数据库
- 控制硬件设备

### 2. 工具使用的重要性

- **扩展能力**：突破LLM自身的知识和能力限制
- **实时性**：获取最新的实时信息
- **准确性**：利用专业工具提高任务执行的准确性
- **交互性**：与外部环境和系统进行交互
- **自动化**：实现端到端的自动化任务执行

### 3. 工具使用的挑战

- **工具选择**：如何选择合适的工具
- **参数生成**：如何生成正确的工具参数
- **结果解析**：如何解析和利用工具返回的结果
- **错误处理**：如何处理工具调用失败的情况
- **安全性**：如何防止恶意工具调用

## 二、工具的定义与设计

### 1. 工具的基本结构

一个标准的智能体工具通常包含以下要素：

- **名称**：工具的唯一标识符
- **描述**：工具的功能说明
- **参数**：工具需要的输入参数
- **返回值**：工具的输出格式
- **执行逻辑**：工具的具体实现

### 2. 基于LangChain 1.0的工具定义

在LangChain 1.0中，工具可以通过`BaseTool`类或函数式工具来定义：

```python
from langchain_core.tools import tool
from langchain_core.pydantic_v1 import BaseModel, Field

# 函数式工具定义（推荐）
@tool
async def search(query: str) -> str:
    """搜索网络获取信息。
    
    Args:
        query: 搜索查询字符串
    
    Returns:
        搜索结果的文本摘要
    """
    # 这里可以集成真实的搜索引擎API
    return f"搜索结果：关于{query}的信息..."

# 使用Pydantic模型定义工具参数
class CalculateInput(BaseModel):
    expression: str = Field(..., description="要计算的数学表达式")

@tool(args_schema=CalculateInput)
async def calculate(input: CalculateInput) -> str:
    """执行数学计算。
    
    Args:
        input: 包含数学表达式的输入对象
    
    Returns:
        计算结果
    """
    try:
        result = eval(input.expression)
        return f"计算结果：{input.expression} = {result}"
    except Exception as e:
        return f"计算错误：{str(e)}"

# 同步工具定义
@tool
def write_file(file_path: str, content: str) -> str:
    """将内容写入文件。
    
    Args:
        file_path: 要写入的文件路径
        content: 要写入的内容
    
    Returns:
        写入操作的结果
    """
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        return f"文件写入成功：{file_path}"
    except Exception as e:
        return f"文件写入错误：{str(e)}"

# 测试工具
if __name__ == "__main__":
    import asyncio
    
    # 测试同步工具
    result = write_file("test.txt", "测试内容")
    print(result)
    
    # 测试异步工具
    async def test_async_tools():
        search_result = await search("智能体开发趋势")
        calculate_result = await calculate(CalculateInput(expression="1+2*3"))
        print(search_result)
        print(calculate_result)
    
    asyncio.run(test_async_tools())
```

### 3. 工具的元数据

工具的元数据对于智能体选择和使用工具有重要作用，包括：

- **名称**：工具的唯一标识符
- **描述**：工具的功能说明
- **参数描述**：每个参数的详细说明
- **返回值描述**：返回值的格式和含义
- **示例**：工具使用的示例

## 三、智能体工具调用机制

### 1. 工具调用的基本流程

智能体调用工具的基本流程包括：

1. **任务分析**：理解用户的任务需求
2. **工具选择**：选择合适的工具
3. **参数生成**：生成工具需要的参数
4. **工具调用**：执行工具调用
5. **结果解析**：解析工具返回的结果
6. **结果处理**：利用工具结果完成任务

### 2. 基于LangChain 1.0的工具调用

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langchain.agents import create_tool_calling_agent, AgentExecutor

# 定义工具
@tool
def search(query: str) -> str:
    """搜索网络获取信息。
    
    Args:
        query: 搜索查询字符串
    
    Returns:
        搜索结果的文本摘要
    """
    return f"搜索结果：关于{query}的信息..."

@tool
def calculate(expression: str) -> str:
    """执行数学计算。
    
    Args:
        expression: 要计算的数学表达式
    
    Returns:
        计算结果
    """
    try:
        result = eval(expression)
        return f"计算结果：{expression} = {result}"
    except Exception as e:
        return f"计算错误：{str(e)}"

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 定义工具列表
tools = [search, calculate]

# 创建提示模板
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个 helpful 的智能助手，能够使用工具完成任务。请根据用户的请求，选择合适的工具并生成正确的参数。"),
    ("user", "{input}"),
    ("placeholder", "{agent_scratchpad}")
])

# 创建工具调用智能体
agent = create_tool_calling_agent(llm, tools, prompt)

# 创建智能体执行器
executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# 测试智能体工具调用
result = executor.invoke({
    "input": "请搜索智能体开发的最新趋势，并计算1+2*3的结果"
})

print("最终结果：")
print(result["output"])
```

### 3. 工具调用的输出解析

智能体需要能够解析工具返回的结果，并将其用于后续的决策和任务执行：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langchain_core.output_parsers import StrOutputParser

# 定义工具
@tool
def get_weather(city: str) -> str:
    """获取指定城市的天气信息。
    
    Args:
        city: 城市名称
    
    Returns:
        天气信息，格式为："城市：北京，天气：晴，温度：25℃，湿度：45%"
    """
    # 模拟天气API返回
    weather_data = {
        "北京": "城市：北京，天气：晴，温度：25℃，湿度：45%",
        "上海": "城市：上海，天气：多云，温度：28℃，湿度：60%",
        "广州": "城市：广州，天气：雨，温度：30℃，湿度：80%"
    }
    return weather_data.get(city, f"未找到{city}的天气信息")

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 创建提示模板
weather_prompt = ChatPromptTemplate.from_template(
    """请获取{city}的天气信息，然后根据天气情况推荐合适的活动。
    
    工具调用结果：
    {weather_result}
    
    要求：
    1. 首先解析天气信息
    2. 然后根据天气情况推荐2-3个合适的活动
    3. 推荐的活动要符合天气条件
    4. 语言要友好自然
    """
)

# 创建链
chain = weather_prompt | llm | StrOutputParser()

# 测试工具结果解析
if __name__ == "__main__":
    # 调用天气工具
    city = "北京"
    weather_result = get_weather(city)
    print(f"天气信息：{weather_result}")
    
    # 解析结果并推荐活动
    recommendation = chain.invoke({
        "city": city,
        "weather_result": weather_result
    })
    print(f"活动推荐：{recommendation}")
```

## 四、工具选择与调度

### 1. 基于LLM的工具选择

智能体可以利用LLM的推理能力来选择合适的工具：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 定义可用工具列表
tools = [
    {
        "name": "search",
        "description": "搜索网络获取信息",
        "parameters": [{"name": "query", "type": "string", "description": "搜索查询字符串"}]
    },
    {
        "name": "calculate",
        "description": "执行数学计算",
        "parameters": [{"name": "expression", "type": "string", "description": "要计算的数学表达式"}]
    },
    {
        "name": "get_weather",
        "description": "获取指定城市的天气信息",
        "parameters": [{"name": "city", "type": "string", "description": "城市名称"}]
    }
]

# 创建工具选择提示模板
prompt = ChatPromptTemplate.from_template(
    """请根据用户请求和可用工具列表，选择合适的工具并生成参数。
    
    用户请求：{user_request}
    
    可用工具列表：
    {tools_list}
    
    输出格式要求：
    {{"tool": "工具名称", "parameters": {{"参数名": "参数值"}}, "reason": "选择该工具的原因"}}
    
    注意：
    1. 只能选择列表中存在的工具
    2. 必须为工具提供所有必要的参数
    3. 参数值必须符合参数类型要求
    4. 必须说明选择该工具的原因
    """
)

# 创建链
chain = prompt | llm | JsonOutputParser()

# 测试工具选择
user_requests = [
    "请计算1+2*3的结果",
    "北京今天的天气怎么样？",
    "智能体开发的最新趋势是什么？"
]

for request in user_requests:
    print(f"\n用户请求：{request}")
    result = chain.invoke({
        "user_request": request,
        "tools_list": tools
    })
    print(f"工具选择结果：")
    print(f"  工具：{result['tool']}")
    print(f"  参数：{result['parameters']}")
    print(f"  原因：{result['reason']}")
```

### 2. 多工具协作

复杂任务通常需要多个工具的协作完成：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langchain.agents import create_tool_calling_agent, AgentExecutor

# 定义工具
@tool
def search(query: str) -> str:
    """搜索网络获取信息。
    
    Args:
        query: 搜索查询字符串
    
    Returns:
        搜索结果的文本摘要
    """
    return f"搜索结果：关于{query}的信息..."

@tool
def calculate(expression: str) -> str:
    """执行数学计算。
    
    Args:
        expression: 要计算的数学表达式
    
    Returns:
        计算结果
    """
    try:
        result = eval(expression)
        return f"计算结果：{expression} = {result}"
    except Exception as e:
        return f"计算错误：{str(e)}"

@tool
def write_file(file_path: str, content: str) -> str:
    """将内容写入文件。
    
    Args:
        file_path: 要写入的文件路径
        content: 要写入的内容
    
    Returns:
        写入操作的结果
    """
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        return f"文件写入成功：{file_path}"
    except Exception as e:
        return f"文件写入错误：{str(e)}"

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 定义工具列表
tools = [search, calculate, write_file]

# 创建提示模板
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个 helpful 的智能助手，能够使用工具完成复杂任务。请根据用户的请求，制定计划并调用合适的工具。"),
    ("user", "{input}"),
    ("placeholder", "{agent_scratchpad}")
])

# 创建工具调用智能体
agent = create_tool_calling_agent(llm, tools, prompt)

# 创建智能体执行器
executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# 测试多工具协作
complex_task = "请搜索智能体开发的最新趋势，计算1+2*3*4的结果，然后将这两部分内容写入到report.txt文件中"

result = executor.invoke({
    "input": complex_task
})

print("\n最终结果：")
print(result["output"])
```

## 五、高级工具使用技术

### 1. 动态工具加载

智能体可以根据需要动态加载和使用工具：

```python
import importlib.util
from langchain_core.tools import BaseTool

class DynamicToolLoader:
    def __init__(self):
        self.tools = {}
    
    def load_tool(self, tool_name: str, tool_path: str):
        """动态加载工具"""
        try:
            # 加载工具模块
            spec = importlib.util.spec_from_file_location(tool_name, tool_path)
            if spec and spec.loader:
                tool_module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(tool_module)
                
                # 获取工具实例或函数
                if hasattr(tool_module, 'tool'):
                    self.tools[tool_name] = tool_module.tool
                    return f"成功加载工具：{tool_name}"
                elif hasattr(tool_module, 'get_tool'):
                    self.tools[tool_name] = tool_module.get_tool()
                    return f"成功加载工具：{tool_name}"
                else:
                    return f"工具模块中未找到tool或get_tool属性：{tool_path}"
            else:
                return f"无法加载工具模块：{tool_path}"
        except Exception as e:
            return f"加载工具时出错：{str(e)}"
    
    def get_tool(self, tool_name: str):
        """获取已加载的工具"""
        return self.tools.get(tool_name)
    
    def list_tools(self):
        """列出已加载的工具"""
        return list(self.tools.keys())

# 测试动态工具加载
if __name__ == "__main__":
    # 创建动态工具加载器
    loader = DynamicToolLoader()
    
    # 创建一个简单的工具文件
    tool_content = '''
from langchain_core.tools import tool

@tool
def dynamic_search(query: str) -> str:
    """动态加载的搜索工具。
    
    Args:
        query: 搜索查询字符串
    
    Returns:
        搜索结果
    """
    return f"动态搜索结果：关于{query}的信息"

# 导出工具
tool = dynamic_search
    '''
    
    # 写入工具文件
    with open('dynamic_tool.py', 'w', encoding='utf-8') as f:
        f.write(tool_content)
    
    # 动态加载工具
    result = loader.load_tool('dynamic_search', 'dynamic_tool.py')
    print(result)
    
    # 列出已加载的工具
    print(f"已加载的工具：{loader.list_tools()}")
    
    # 使用动态加载的工具
    search_tool = loader.get_tool('dynamic_search')
    if search_tool:
        result = search_tool.invoke("智能体开发")
        print(f"工具调用结果：{result}")
```

### 2. 工具使用的监控与日志

监控和日志对于工具使用的调试和优化非常重要：

```python
from langchain_core.tools import tool
import logging
from functools import wraps

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# 工具调用装饰器
def tool_with_logging(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        # 记录工具调用开始
        logger.info(f"工具调用开始：{func.__name__}")
        logger.info(f"  参数：args={args}, kwargs={kwargs}")
        
        try:
            # 执行工具
            result = func(*args, **kwargs)
            
            # 记录工具调用成功
            logger.info(f"工具调用成功：{func.__name__}")
            logger.info(f"  返回值：{result}")
            
            return result
        except Exception as e:
            # 记录工具调用失败
            logger.error(f"工具调用失败：{func.__name__}")
            logger.error(f"  错误信息：{str(e)}")
            raise
    return wrapper

# 定义带日志的工具
@tool
tool_with_logging
def search_with_logging(query: str) -> str:
    """带日志的搜索工具。
    
    Args:
        query: 搜索查询字符串
    
    Returns:
        搜索结果
    """
    return f"搜索结果：关于{query}的信息..."

# 测试带日志的工具
if __name__ == "__main__":
    result = search_with_logging.invoke("智能体开发")
    print(f"工具调用结果：{result}")
```

### 3. 工具使用的安全性

工具使用的安全性是智能体开发中的重要考虑因素：

```python
from langchain_core.tools import tool
from langchain_core.pydantic_v1 import BaseModel, Field

# 安全检查装饰器
def safe_tool(func):
    def wrapper(*args, **kwargs):
        # 实现安全检查逻辑
        # 1. 参数验证
        # 2. 权限检查
        # 3. 恶意输入检测
        # 4. 资源限制
        
        # 示例：简单的参数安全检查
        if args:
            for arg in args:
                if isinstance(arg, str):
                    # 检查是否包含恶意命令
                    dangerous_patterns = ["rm -rf", "eval", "exec", "os.system"]
                    for pattern in dangerous_patterns:
                        if pattern in arg:
                            raise ValueError(f"参数包含不安全的内容：{pattern}")
        
        if kwargs:
            for key, value in kwargs.items():
                if isinstance(value, str):
                    dangerous_patterns = ["rm -rf", "eval", "exec", "os.system"]
                    for pattern in dangerous_patterns:
                        if pattern in value:
                            raise ValueError(f"参数{key}包含不安全的内容：{pattern}")
        
        # 执行工具
        return func(*args, **kwargs)
    return wrapper

# 定义安全工具
@tool
safe_tool
def write_file_safe(file_path: str, content: str) -> str:
    """安全的文件写入工具。
    
    Args:
        file_path: 要写入的文件路径
        content: 要写入的内容
    
    Returns:
        写入操作的结果
    """
    try:
        # 额外的安全检查：限制文件路径
        import os
        allowed_dirs = ['.', './output', './files']
        abs_path = os.path.abspath(file_path)
        
        # 检查文件路径是否在允许的目录中
        if not any(abs_path.startswith(os.path.abspath(d)) for d in allowed_dirs):
            return f"安全错误：不允许写入到该目录"
        
        # 执行文件写入
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        return f"文件写入成功：{file_path}"
    except Exception as e:
        return f"文件写入错误：{str(e)}"

# 测试安全工具
if __name__ == "__main__":
    # 正常调用
    result1 = write_file_safe.invoke({
        "file_path": "./output/test.txt",
        "content": "正常内容"
    })
    print(f"正常调用结果：{result1}")
    
    # 恶意调用（尝试写入到禁止目录）
    try:
        result2 = write_file_safe.invoke({
            "file_path": "/etc/passwd",
            "content": "恶意内容"
        })
        print(f"恶意调用结果：{result2}")
    except Exception as e:
        print(f"恶意调用被拒绝：{str(e)}")
    
    # 恶意调用（尝试执行命令）
    try:
        result3 = write_file_safe.invoke({
            "file_path": "./test.txt",
            "content": "rm -rf /"
        })
        print(f"恶意内容调用结果：{result3}")
    except Exception as e:
        print(f"恶意内容被拒绝：{str(e)}")
```

## 六、智能体工具使用的完整案例

### 1. 股票分析智能体

```python
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_core.prompts import ChatPromptTemplate

# 定义股票相关工具
@tool
def get_stock_price(symbol: str) -> str:
    """获取指定股票的当前价格。
    
    Args:
        symbol: 股票代码，如AAPL、GOOGL等
    
    Returns:
        股票价格信息，格式为："股票代码：AAPL，当前价格：180.50美元，涨跌幅：+2.3%"
    """
    # 模拟股票API返回
    stock_data = {
        "AAPL": "股票代码：AAPL，当前价格：180.50美元，涨跌幅：+2.3%",
        "GOOGL": "股票代码：GOOGL，当前价格：142.30美元，涨跌幅：-1.2%",
        "MSFT": "股票代码：MSFT，当前价格：378.90美元，涨跌幅：+0.8%"
    }
    return stock_data.get(symbol, f"未找到{symbol}的股票信息")

@tool
def get_stock_news(symbol: str) -> str:
    """获取指定股票的最新新闻。
    
    Args:
        symbol: 股票代码
    
    Returns:
        股票新闻列表，每条新闻包含标题和摘要
    """
    # 模拟新闻API返回
    news_data = {
        "AAPL": "1. 苹果发布新款iPhone，销量超出预期\n2. 分析师上调苹果目标价至200美元\n3. 苹果计划扩大印度生产线",
        "GOOGL": "1. 谷歌AI产品获得重大突破\n2. 欧盟对谷歌罚款20亿美元\n3. 谷歌云业务增长强劲",
        "MSFT": "1. 微软AI助手Copilot用户突破1亿\n2. 微软收购动视暴雪获得批准\n3. 微软财报超出市场预期"
    }
    return news_data.get(symbol, f"未找到{symbol}的新闻信息")

@tool
def analyze_stock(symbol: str) -> str:
    """分析指定股票的投资价值。
    
    Args:
        symbol: 股票代码
    
    Returns:
        股票分析报告，包含基本面分析和投资建议
    """
    # 模拟分析API返回
    analysis_data = {
        "AAPL": "基本面分析：苹果公司财务状况良好，现金流充足，产品线丰富。\n投资建议：买入，目标价200美元。\n风险因素：全球供应链风险，市场竞争加剧。",
        "GOOGL": "基本面分析：谷歌在搜索和广告市场占据主导地位，AI技术领先。\n投资建议：持有，目标价150美元。\n风险因素：监管风险，AI伦理问题。",
        "MSFT": "基本面分析：微软云业务增长迅速，AI战略清晰。\n投资建议：强烈买入，目标价400美元。\n风险因素：AI投入成本高，市场竞争激烈。"
    }
    return analysis_data.get(symbol, f"未找到{symbol}的分析信息")

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 定义工具列表
tools = [get_stock_price, get_stock_news, analyze_stock]

# 创建提示模板
prompt = ChatPromptTemplate.from_messages([
    ("system", "你是一个专业的股票分析智能体，能够使用各种股票工具来分析股票。请根据用户的请求，选择合适的工具并生成正确的参数。"),
    ("user", "{input}"),
    ("placeholder", "{agent_scratchpad}")
])

# 创建智能体
agent = create_tool_calling_agent(llm, tools, prompt)

# 创建智能体执行器
executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# 测试股票分析智能体
if __name__ == "__main__":
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    user_requests = [
        "请分析苹果(AAPL)股票的投资价值",
        "微软(MSFT)的当前价格是多少？",
        "谷歌(GOOGL)的最新新闻有哪些？"
    ]
    
    for request in user_requests:
        print(f"\n=== 用户请求：{request} ===")
        result = executor.invoke({"input": request})
        print(f"=== 智能体回复：{result['output']} ===")
```

## 七、总结

智能体工具使用是智能体开发中的核心能力之一，它使智能体能够突破自身的限制，与外部环境和系统进行交互，完成更复杂的任务。通过本章节的学习，你应该掌握：

- 工具使用的基本概念和重要性
- 工具的定义与设计方法
- 基于LangChain 1.0的工具调用机制
- 工具选择与多工具协作
- 高级工具使用技术（动态加载、监控、安全性）
- 完整的工具使用案例

在实际开发中，你可以根据具体需求设计和实现各种工具，并将其集成到智能体系统中，以扩展智能体的能力范围，实现更复杂的自动化任务。
