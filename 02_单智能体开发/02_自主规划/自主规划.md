# 智能体自主规划

## 一、自主规划概述

### 1. 什么是自主规划

自主规划是智能体根据目标和环境信息，自主制定行动方案的能力。它是智能体实现复杂任务的核心能力之一，使智能体能够：

- 理解复杂目标
- 分解任务为可执行的子步骤
- 规划执行顺序
- 处理执行过程中的不确定性
- 适应环境变化

### 2. 自主规划的类型

- **基于规则的规划**：根据预定义的规则和知识库进行规划
- **基于搜索的规划**：通过搜索可能的行动序列找到最优方案
- **基于LLM的规划**：利用大语言模型的推理能力生成规划
- **混合规划**：结合多种规划方法的优点

### 3. 自主规划的挑战

- **复杂性**：随着任务复杂度增加，规划空间呈指数级增长
- **不确定性**：环境和执行结果的不确定性
- **动态性**：环境的动态变化要求规划能够实时调整
- **资源约束**：计算资源和时间的限制

## 二、基于LLM的自主规划

### 1. LLM规划的优势

- **自然语言理解**：能够理解人类的自然语言指令
- **常识推理**：具备丰富的常识知识
- **灵活性**：能够处理各种类型的任务
- **少样本学习**：只需少量示例即可学会新任务
- **自适应性**：能够根据反馈调整规划

### 2. 基于LLM的规划方法

#### （1）直接提示规划

直接向LLM描述任务，让其生成完整的规划：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 创建提示模板
prompt = ChatPromptTemplate.from_template(
    """请为以下任务生成详细的执行计划：
    任务：{task}
    请按照以下格式输出：
    1. 第一步：[具体行动]
    2. 第二步：[具体行动]
    ...
    """
)

# 创建链
chain = prompt | llm | StrOutputParser()

# 执行规划
task = "准备一顿晚餐，包括主菜、配菜和甜点"
plan = chain.invoke({"task": task})
print("生成的计划：")
print(plan)
```

#### （2）思维链规划

引导LLM逐步思考，生成更可靠的规划：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 创建思维链提示模板
prompt = ChatPromptTemplate.from_template(
    """请为以下任务生成详细的执行计划，先思考任务的组成部分，再分解为具体步骤：
    任务：{task}
    
    思考过程：
    1. 首先，我需要理解任务的目标和要求
    2. 然后，分解任务为主要组成部分
    3. 接着，为每个组成部分制定具体步骤
    4. 最后，按逻辑顺序组织所有步骤
    
    执行计划：
    """
)

# 创建链
chain = prompt | llm | StrOutputParser()

# 执行规划
task = "组织一次户外野餐"
plan = chain.invoke({"task": task})
print("生成的计划：")
print(plan)
```

#### （3）基于示例的规划

提供示例帮助LLM理解规划格式和要求：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import FewShotChatMessagePromptTemplate, ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 定义示例
examples = [
    {
        "input": "去超市买东西",
        "output": """1. 第一步：制作购物清单
2. 第二步：检查钱包和钥匙
3. 第三步：前往超市
4. 第四步：按清单购买商品
5. 第五步：结账
6. 第六步：返回 home"""
    },
    {
        "input": "准备一杯咖啡",
        "output": """1. 第一步：准备咖啡豆和咖啡机
2. 第二步：研磨咖啡豆
3. 第三步：将咖啡粉放入咖啡机
4. 第四步：启动咖啡机
5. 第五步：等待咖啡冲泡完成
6. 第六步：倒入杯子中"""
    }
]

# 创建示例提示
example_prompt = ChatPromptTemplate.from_messages([
    ("user", "{input}"),
    ("assistant", "{output}")
])

# 创建少样本提示
few_shot_prompt = FewShotChatMessagePromptTemplate(
    example_prompt=example_prompt,
    examples=examples
)

# 创建最终提示
final_prompt = ChatPromptTemplate.from_messages([
    ("system", "请按照示例格式为以下任务生成详细的执行计划："),
    few_shot_prompt,
    ("user", "{task}")
])

# 创建链
chain = final_prompt | llm | StrOutputParser()

# 执行规划
task = "修理自行车轮胎"
plan = chain.invoke({"task": task})
print("生成的计划：")
print(plan)
```

## 三、任务分解与调度

### 1. 任务分解的原则

- **可行性**：每个子任务必须是可执行的
- **独立性**：子任务之间的依赖关系尽可能少
- **完整性**：所有子任务完成后，总任务必须完成
- **最优性**：分解方案应优化执行效率和资源使用

### 2. 基于LLM的任务分解

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 创建提示模板
prompt = ChatPromptTemplate.from_template(
    """请将以下任务分解为具体的子任务，并生成JSON格式输出：
    任务：{task}
    
    JSON格式要求：
    {{"task": "总任务描述", "subtasks": [{{"id": "子任务ID", "description": "子任务描述", "dependencies": ["依赖的子任务ID"]}}]}}
    
    注意：
    - 子任务ID应按顺序编号
    - dependencies为可选字段，指定子任务的依赖关系
    - 子任务应具备可行性和独立性
    """
)

# 创建链
chain = prompt | llm | JsonOutputParser()

# 执行任务分解
task = "开发一个智能聊天机器人"
result = chain.invoke({"task": task})

print("任务分解结果：")
print(f"总任务：{result['task']}")
print("子任务：")
for subtask in result['subtasks']:
    deps = subtask.get('dependencies', [])
    print(f"  {subtask['id']}. {subtask['description']} {f'(依赖：{deps})' if deps else ''}")
```

### 3. 任务调度策略

- **顺序执行**：按顺序执行所有子任务
- **并行执行**：同时执行相互独立的子任务
- **依赖驱动**：根据依赖关系动态调度
- **优先级调度**：根据子任务的优先级调度

```python
class TaskScheduler:
    def __init__(self):
        self.tasks = []
        self.completed_tasks = set()
    
    def add_task(self, task_id, description, dependencies=None):
        """添加任务"""
        if dependencies is None:
            dependencies = []
        self.tasks.append({
            'id': task_id,
            'description': description,
            'dependencies': dependencies,
            'status': 'pending'  # pending, running, completed, failed
        })
    
    def get_ready_tasks(self):
        """获取可执行的任务"""
        ready_tasks = []
        for task in self.tasks:
            if task['status'] == 'pending':
                # 检查所有依赖是否已完成
                all_deps_completed = all(dep in self.completed_tasks for dep in task['dependencies'])
                if all_deps_completed:
                    ready_tasks.append(task)
        return ready_tasks
    
    def mark_task_completed(self, task_id):
        """标记任务为已完成"""
        self.completed_tasks.add(task_id)
        for task in self.tasks:
            if task['id'] == task_id:
                task['status'] = 'completed'
                break
    
    def mark_task_failed(self, task_id):
        """标记任务为失败"""
        for task in self.tasks:
            if task['id'] == task_id:
                task['status'] = 'failed'
                break
    
    def schedule(self):
        """执行任务调度"""
        execution_order = []
        
        while True:
            ready_tasks = self.get_ready_tasks()
            if not ready_tasks:
                break
            
            # 简单的调度策略：按ID顺序执行
            ready_tasks.sort(key=lambda x: x['id'])
            
            for task in ready_tasks:
                # 执行任务（这里仅模拟）
                print(f"执行任务：{task['id']}. {task['description']}")
                execution_order.append(task['id'])
                
                # 标记任务为已完成
                self.mark_task_completed(task['id'])
        
        return execution_order

# 测试任务调度器
scheduler = TaskScheduler()

# 添加任务
scheduler.add_task("1", "需求分析")
scheduler.add_task("2", "设计架构", dependencies=["1"])
scheduler.add_task("3", "开发核心功能", dependencies=["2"])
scheduler.add_task("4", "编写测试用例", dependencies=["2"])
scheduler.add_task("5", "执行测试", dependencies=["3", "4"])
scheduler.add_task("6", "部署上线", dependencies=["5"])

# 执行调度
execution_order = scheduler.schedule()

print(f"\n任务执行顺序：{execution_order}")
```

## 四、规划执行与反馈

### 1. 规划执行的监控

智能体需要监控规划的执行过程，包括：

- 执行状态的跟踪
- 执行结果的验证
- 执行时间的监控
- 资源使用的监控

### 2. 基于反馈的规划调整

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 创建规划调整提示模板
prompt = ChatPromptTemplate.from_template(
    """请根据原始规划和执行反馈，调整规划：
    
    原始规划：
    {original_plan}
    
    执行反馈：
    {feedback}
    
    调整要求：
    1. 保留未执行的有效步骤
    2. 修改或替换失败的步骤
    3. 添加必要的新步骤
    4. 调整步骤顺序以适应新情况
    5. 保持规划的完整性和可行性
    
    调整后的规划：
    """
)

# 创建链
chain = prompt | llm | StrOutputParser()

# 示例：原始规划
original_plan = """1. 第一步：去超市购买食材
2. 第二步：回家准备食材
3. 第三步：烹饪主菜
4. 第四步：准备配菜
5. 第五步：摆放餐桌
6. 第六步：享用晚餐"""

# 示例：执行反馈
feedback = """已完成步骤1：去超市购买食材，但发现超市的新鲜鱼已经卖完了
当前进度：已完成步骤1，准备执行步骤2
需要调整：主菜原计划是鱼，现在需要更换为其他食材"""

# 执行规划调整
adjusted_plan = chain.invoke({
    "original_plan": original_plan,
    "feedback": feedback
})

print("调整后的规划：")
print(adjusted_plan)
```

### 3. 自主反思机制

智能体可以通过反思机制，评估规划的执行效果，不断改进规划能力：

```python
class PlanningReflector:
    def __init__(self, llm):
        self.llm = llm
        self.prompt = ChatPromptTemplate.from_template(
            """请作为规划评估专家，分析以下规划执行情况，并提供改进建议：
            
            任务：{task}
            规划：{plan}
            执行结果：{execution_result}
            
            分析维度：
            1. 规划的完整性：是否覆盖了所有必要步骤
            2. 规划的合理性：步骤顺序是否合理
            3. 规划的可行性：步骤是否具备可执行性
            4. 执行中的问题：执行过程中遇到了哪些问题
            5. 改进建议：如何改进规划以避免类似问题
            
            分析报告：
            """
        )
        self.chain = self.prompt | self.llm | StrOutputParser()
    
    def reflect(self, task, plan, execution_result):
        """执行规划反思"""
        return self.chain.invoke({
            "task": task,
            "plan": plan,
            "execution_result": execution_result
        })

# 测试自主反思机制
reflector = PlanningReflector(llm)

# 示例数据
task = "准备一顿晚餐"
plan = """1. 第一步：去超市购买食材
2. 第二步：回家准备食材
3. 第三步：烹饪主菜
4. 第四步：准备配菜
5. 第五步：摆放餐桌
6. 第六步：享用晚餐"""
execution_result = """执行情况：
- 步骤1：成功购买了食材
- 步骤2：成功准备了食材
- 步骤3：烹饪主菜时发现烤箱故障，导致主菜烹饪失败
- 步骤4：成功准备了配菜
- 步骤5：成功摆放了餐桌
- 最终结果：晚餐不完整，缺少主菜"""

# 执行反思
analysis = reflector.reflect(task, plan, execution_result)
print("规划分析报告：")
print(analysis)
```

## 五、高级规划技术

### 1. 层次化规划

将规划分为多个层次，从高层抽象到低层具体：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

class HierarchicalPlanner:
    def __init__(self, llm):
        self.llm = llm
        
        # 高层规划提示
        self.high_level_prompt = ChatPromptTemplate.from_template(
            """请为以下任务生成高层规划，包含主要阶段：
            任务：{task}
            
            高层规划应包含3-5个主要阶段，每个阶段描述一个主要目标
            """
        )
        
        # 低层规划提示
        self.low_level_prompt = ChatPromptTemplate.from_template(
            """请为以下高层规划阶段生成详细的低层规划：
            阶段：{stage}
            阶段目标：{stage_goal}
            
            低层规划应包含具体的可执行步骤
            """
        )
        
        # 创建链
        self.high_level_chain = self.high_level_prompt | self.llm | StrOutputParser()
        self.low_level_chain = self.low_level_prompt | self.llm | StrOutputParser()
    
    def plan(self, task):
        """执行层次化规划"""
        # 生成高层规划
        high_level_plan = self.high_level_chain.invoke({"task": task})
        print("高层规划：")
        print(high_level_plan)
        print()
        
        # 解析高层规划阶段
        stages = []
        for line in high_level_plan.strip().split('\n'):
            if line.strip() and '.' in line:
                parts = line.split('.', 1)
                if len(parts) == 2:
                    stage_id = parts[0].strip()
                    stage_goal = parts[1].strip()
                    stages.append((stage_id, stage_goal))
        
        # 生成低层规划
        low_level_plans = []
        for stage_id, stage_goal in stages:
            print(f"生成阶段 {stage_id} 的低层规划：{stage_goal}")
            low_level_plan = self.low_level_chain.invoke({
                "stage": stage_id,
                "stage_goal": stage_goal
            })
            low_level_plans.append((stage_id, stage_goal, low_level_plan))
            print(low_level_plan)
            print()
        
        return {
            "high_level_plan": high_level_plan,
            "low_level_plans": low_level_plans
        }

# 测试层次化规划器
planner = HierarchicalPlanner(llm)

# 执行层次化规划
task = "组织一次国际学术会议"
result = planner.plan(task)
```

### 2. 多路径规划

生成多个可能的规划路径，提高鲁棒性：

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# 初始化LLM
llm = ChatOpenAI(model="gpt-3.5-turbo")

# 创建提示模板
prompt = ChatPromptTemplate.from_template(
    """请为以下任务生成{num_paths}个不同的执行规划路径：
    任务：{task}
    
    每个规划路径应包含不同的执行顺序或方法
    每个规划路径应以"路径X："开头
    """
)

# 创建链
chain = prompt | llm | StrOutputParser()

# 执行多路径规划
task = "从北京到上海旅行"
num_paths = 3
plans = chain.invoke({
    "task": task,
    "num_paths": num_paths
})

print("多路径规划结果：")
print(plans)
```

## 六、规划系统的集成

### 1. 与智能体核心组件的集成

将规划系统与智能体的其他组件集成，形成完整的智能体系统：

```python
class PlanningAgent:
    def __init__(self, api_key):
        from langchain_openai import ChatOpenAI
        from langchain_core.prompts import ChatPromptTemplate
        from langchain_core.output_parsers import StrOutputParser
        
        # 初始化各个模块
        self.llm = ChatOpenAI(api_key=api_key, model="gpt-3.5-turbo")
        
        # 初始化规划模块
        self.plan_prompt = ChatPromptTemplate.from_template(
            """请为以下任务生成详细的执行计划：
            任务：{task}
            当前状态：{current_state}
            可用工具：{tools}
            
            执行计划应包含具体的步骤和预期结果
            """
        )
        self.plan_chain = self.plan_prompt | self.llm | StrOutputParser()
        
        # 初始化执行模块（简化版）
        self.tools = {
            'search': self._execute_search,
            'calculate': self._execute_calculate,
            'write_file': self._execute_write_file
        }
    
    def _execute_search(self, query):
        """执行搜索"""
        print(f"执行搜索：{query}")
        return f"搜索结果：关于{query}的信息"
    
    def _execute_calculate(self, expression):
        """执行计算"""
        print(f"执行计算：{expression}")
        try:
            result = eval(expression)
            return f"计算结果：{expression} = {result}"
        except Exception as e:
            return f"计算错误：{str(e)}"
    
    def _execute_write_file(self, file_path, content):
        """执行文件写入"""
        print(f"执行文件写入：{file_path}")
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return f"文件写入成功：{file_path}"
        except Exception as e:
            return f"文件写入错误：{str(e)}"
    
    def plan(self, task, current_state="空闲"):
        """生成规划"""
        tools_list = list(self.tools.keys())
        plan = self.plan_chain.invoke({
            "task": task,
            "current_state": current_state,
            "tools": ", ".join(tools_list)
        })
        return plan
    
    def execute_step(self, step):
        """执行单个步骤"""
        # 简单的步骤解析：提取动作和参数
        words = step.strip().split()
        if not words:
            return "无效步骤"
        
        action = words[0].lower()
        params = " ".join(words[1:])
        
        if action in self.tools:
            return self.tools[action](params)
        else:
            return f"不支持的动作：{action}"
    
    def run(self, task):
        """运行智能体，执行完整任务"""
        print(f"开始执行任务：{task}")
        
        # 1. 生成规划
        plan = self.plan(task)
        print("\n生成的规划：")
        print(plan)
        
        # 2. 解析规划步骤
        steps = []
        for line in plan.strip().split('\n'):
            if line.strip() and '.' in line:
                parts = line.split('.', 1)
                if len(parts) == 2:
                    step_num = parts[0].strip()
                    step_content = parts[1].strip()
                    steps.append((step_num, step_content))
        
        # 3. 执行规划
        results = []
        for step_num, step_content in steps:
            print(f"\n执行步骤 {step_num}：{step_content}")
            result = self.execute_step(step_content)
            results.append((step_num, step_content, result))
            print(f"执行结果：{result}")
        
        # 4. 生成最终报告
        report = {
            "task": task,
            "plan": plan,
            "execution_results": results
        }
        
        return report

# 测试规划智能体
if __name__ == "__main__":
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    agent = PlanningAgent(api_key=os.getenv("OPENAI_API_KEY"))
    
    # 运行智能体
    task = "请计算1+2*3的结果，并将结果写入到result.txt文件中"
    result = agent.run(task)
    
    print("\n最终报告：")
    print(f"任务：{result['task']}")
    print("执行结果汇总：")
    for step_num, step_content, step_result in result['execution_results']:
        print(f"  步骤 {step_num}：{step_content} -> {step_result}")
```

## 七、总结

自主规划是智能体实现复杂任务的核心能力，基于LLM的自主规划已经成为当前智能体开发的主流方法。通过本章节的学习，你应该掌握：

- 自主规划的基本概念和类型
- 基于LLM的规划方法和技术
- 任务分解与调度策略
- 规划执行与反馈机制
- 高级规划技术
- 规划系统与智能体核心组件的集成

在实际开发中，你可以根据具体需求选择合适的规划方法，并结合智能体的其他能力，构建功能强大的智能体系统。
